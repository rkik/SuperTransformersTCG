-- Modified by Rkik in 2018 for Transformers TCG.

function onLoad()
  math.randomseed(os.time())
  -- Throw away a few numbers per the Lua documentation.  The first number may not be random.
  math.random()
  math.random()
  math.random()

  --allExpansionLegendaries  = {}
  --allExpansionRares        = {}
  --allExpansionUncommons    = {}
  --allExpansionCommons      = {}

  -- Awakenings, Spirit of Rebellion, Empire at War, Legacies
  --expansions               = { 'AW', 'SoR', 'EaW', 'LEG', 'WotF' }
  --numExpansions            = #expansions

  --draftOriginDeckZone      = nil
  --rivalsDummyCardGuid      = '72db11'
  --rivalsDummyCard          = getObjectFromGUID(rivalsDummyCardGuid)
  --rivalsDummyCard.setLock(true)
  --rivalsDummyCard.interactable = false
  --awakeningsCycleDeckGuid  = '60e044'
  --legaciesCycleDeckGuid    = '4e9040'
  --allCardsDeckGuid         = '9fdb61'
  --rivalsDeckZoneGuid       = '2410f1'
  --rivalsDeckGuid           = 'fd83c6'
  --cubeBoardGuid            = 'c51c41'
  --cubeDeckZoneGuid         = 'b9d302'
  --cubeBoard                = getObjectFromGUID(cubeBoardGuid)
  --cubeBoard.interactable   = false
  --cubeDeckZone             = getObjectFromGUID(cubeDeckZoneGuid)
  --cubeDeck                 = nil
  --cubeCompatibilityMode    = false
  --allCardsPulledDeck       = nil
  --packSelections           = { 'WotF', 'WotF', 'WotF', 'WotF', 'WotF', 'WotF', 'WotF', 'WotF' }
  --packSelectButtons        = nil
  --numPacksPerPlayer        = 6
  --rivalsExpansion          = nil
  --nextExpansionIndex       = {}
  --rivalsExpansionPacks     = {}

  Global.setVar("rivalsDeckZoneGuid", rivalsDeckZoneGuid)

  setupBagGuid             = '771f25'

  blueBoardsPrefab         = nil
  redBoardsPrefab          = nil
  --blueResourceZone         = nil
  --blueBattlefieldZone      = nil
  blueMatZone              = nil
  --redResourceZone          = nil
  --redBattlefieldZone       = nil
  redMatZone               = nil

  setupObject = getObjectFromGUID(setupBagGuid)

  spawnditems              = {}
  mainMenu()
  --affiliationselect        = 'Hero'
  --affiliationselect2       = 'villain'
  --affiliationselect3       = 'Neutral'
  --typeselect               = 'Character'
  --typeselect2              = 'Upgrade'
  --typeselect3              = 'Support'
  --typeselect4              = 'Event'
  --colorselect              = 'Red'
  --colorselect2             = 'Blue'
  --colorselect3             = 'Yellow'
  --colorselect4             = 'Gray'

  -- Make the main menu GUI panel visible.
  Global.UI.setAttribute("main_menu_panel", "active", true)

  red                      = nil
  blue                     = nil
  starterGame              = false
end

-- NOTE:  This function currently only supports Blue and Red players.
function zoomCameraBackOut(playerColor)
  if playerColor == "Blue" then
    Player[playerColor].lookAt({ position={0,0,0}, pitch=62, yaw=180, distance=60})
  elseif playerColor == "Red" then
    Player[playerColor].lookAt({ position={0,0,0}, pitch=62, yaw=0, distance=60})
  else
    printToAll("Error, camera zoom out not supported for player color " .. playerColor .. ".", {1,0,0})
  end
end

function twoPlayerModernFromGUI(player)
  local seatedPlayers = getSeatedPlayers()
  local numSeatedPlayers = 0
  for i,somePlayer in pairs(seatedPlayers) do
    numSeatedPlayers = numSeatedPlayers + 1
  end

  if ((numSeatedPlayers == 1) or (numSeatedPlayers == 2)) then
    twoPlayerModernGeneral(player)
  else
    printToAll("Error, two-player games must have 1 or 2 seated players.", {1,0,0})
  end
end

function twoPlayerModernFromClassic(buttonObject, playerColor)
  local seatedPlayers = getSeatedPlayers()
  local numSeatedPlayers = 0
  for i,somePlayer in pairs(seatedPlayers) do
    numSeatedPlayers = numSeatedPlayers + 1
  end

  if ((numSeatedPlayers == 1) or (numSeatedPlayers == 2)) then
    -- Hide the classic menu board immediately.
    self.setPosition({0,-4,0})

    -- Zoom camera back out to the normal perspective for that player.
    zoomCameraBackOut(playerColor)

    -- Delay slightly so camera movement does not feel too sudden.
    Wait.time(function() twoPlayerModernGeneral(Player[playerColor]) end, 0.2)
  else
    printToAll("Error, two-player games must have 1 or 2 seated players.", {1,0,0})
  end
end

function twoPlayerModernGeneral(playerColor)
  Global.setVar("mainMenuPanelOpen", false)
  Global.UI.setAttribute("main_menu_panel", "active", false)

  startLuaCoroutine(self, 'twoPlayerModernCoroutine')
end

function twoPlayerModernCoroutine()
  -- Sleep briefly and start.
  Wait.time(modernSetupAfterDelay, 0.1)

  return 1
end

function modernSetupAfterDelay()
  startLuaCoroutine(self, 'modernSetupCoroutine')
end

function modernSetupCoroutine()
  local obj_parameters = {}
  local seatData = Global.getTable("seatData")

  -- Destruct all draft mats.
  local matObject
  for i,someSeat in pairs(seatData) do
    matObject = getObjectFromGUID(someSeat.matGuid)
    if matObject != nil then
      matObject.destruct()
    end
  end

  -- Scale all hand zones down so they don't grab cards.
  for i,someSeat in pairs(seatData) do
    local handTransform = Player[i].getHandTransform()
    handTransform.scale.x = 0.01
    handTransform.scale.y = 0.01
    handTransform.scale.z = 0.01
    Player[i].setHandTransform(handTransform)
  end

  -- Adjust the red and blue hand zones to be usable.
  local handTransform = Player["Red"].getHandTransform()
  handTransform.position.x = -1.70
  handTransform.position.y = 4.60
  handTransform.position.z = (-20.00)
  handTransform.rotation.x = 0.00
  handTransform.rotation.y = 0.00
  handTransform.rotation.z = 0.00
  handTransform.scale.x = 20.00
  handTransform.scale.y = 5.65
  handTransform.scale.z = 3.00
  Player["Red"].setHandTransform(handTransform)
  handTransform = Player["Blue"].getHandTransform()
  handTransform.position.x = 1.70
  handTransform.position.y = 4.60
  handTransform.position.z = 20.00
  handTransform.rotation.x = 0.00
  handTransform.rotation.y = 180.00
  handTransform.rotation.z = 0.00
  handTransform.scale.x = 20.00
  handTransform.scale.y = 5.65
  handTransform.scale.z = 3.00
  Player["Blue"].setHandTransform(handTransform)

  local seatedPlayers = getSeatedPlayers()
  local numSeatedPlayers = 0
  for i,somePlayer in pairs(seatedPlayers) do
    numSeatedPlayers = numSeatedPlayers + 1
  end

  if ((numSeatedPlayers == 1) or (numSeatedPlayers == 2)) then
    local firstPlayerToAssign = nil
    local secondPlayerToAssign = nil
    local blueUsed = false
    local redUsed = false
    local colorChangeNeeded = false
    for i,somePlayer in pairs(seatedPlayers) do
      if somePlayer == "Blue" then
        blueUsed = true
      elseif somePlayer == "Red" then
        redUsed = true
      else
        if firstPlayerToAssign == nil then
          firstPlayerToAssign = somePlayer
          colorChangeNeeded = true
        else
          secondPlayerToAssign = somePlayer
          colorChangeNeeded = true
        end
      end
    end

    -- If either or both players are not blue/red, change their color(s).

    if firstPlayerToAssign != nil then
      if blueUsed == false then
        Player[firstPlayerToAssign].changeColor("Blue")
        blueUsed = true
      else
        -- If blue is used, then red must not be used, otherwise firstPlayerToAssign would be nil.
        Player[firstPlayerToAssign].changeColor("Red")
        redUsed = true
      end
    end

    if secondPlayerToAssign != nil then
      -- If neither player was blue or red, the first player got assigned to blue, so this one should be red.
      Player[secondPlayerToAssign].changeColor("Red")
      redUsed = true
    end

    if colorChangeNeeded == true then
      printToAll("Two-player games only use the Blue and Red seats.", {1,1,1})
    end
  else
    printToAll("Error, two-player games must have 1 or 2 seated players.", {1,0,0})

    return 1
  end

  -- At this point, a normal game is considered to have started.
  Global.call("handleNormalGameStarted")

  ---- Create a scripting zone for resources.
  --obj_parameters.type = 'ScriptingTrigger'
  --obj_parameters.position = {-23.00, -4.00, 0.32}
  --obj_parameters.rotation = {0.00, 0.00, 0.00}
  --obj_parameters.scale = {5.50, 5.10, 8.00}
  --blueResourceZone = spawnObject(obj_parameters)
  ---- Create a scripting zone for the battlefield.
  --obj_parameters.type = 'ScriptingTrigger'
  --obj_parameters.position = {-18.39, -4.00, 0.27}
  --obj_parameters.rotation = {0.00, 0.00, 0.00}
  --obj_parameters.scale = {4.60, 5.10, 3.40}
  --blueBattlefieldZone = spawnObject(obj_parameters)
  -- Create a scripting zone for the mat.
  obj_parameters.type = 'ScriptingTrigger'
  obj_parameters.position = {4.82, -4.00, 10.20}
  obj_parameters.rotation = {0.00, 0.00, 0.00}
  obj_parameters.scale = {41.22, 1.00, 12.46}
  blueMatZone = spawnObject(obj_parameters)

  if Global.getVar("boardStyle") == "board_super_black" then
    blueBoardsPrefab = setupObject.takeObject({position={-20.85, -3.00, 10.05}, rotation={0,180,0}, guid=Global.getVar("blueBoardsBlackGuid"), flip=false, smooth=false})
  else
    blueBoardsPrefab = setupObject.takeObject({position={-20.85, -3.00, 10.05}, rotation={0,180,0}, guid=Global.getVar("blueBoardsTransparentGuid"), flip=false, smooth=false})
  end
  blueBoardsPrefab.use_gravity = false
  blueBoardsPrefab.interactable = false
  blueBoardsPrefab.setLock(true)
  blueBoardsPrefab.setName("Blue")
  blueBoardsPrefab.tooltip = false
  blueBoardsPrefab.setLuaScript(modernBoardsScript)
  --blueBoardsPrefab.createButton({
  --  click_function="blueClaimBattlefield", function_owner=Global,
  --  position={2.56, 0.14, 6.89}, width=1400, height=720, font_size=72, color={0,0,0,0}
  --})

  ---- Create a scripting zone for resources.
  --obj_parameters.type = 'ScriptingTrigger'
  --obj_parameters.position = {23.00, -4.00, -0.32}
  --obj_parameters.rotation = {0.00, 0.00, 0.00}
  --obj_parameters.scale = {5.50, 5.10, 8.00}
  --redResourceZone = spawnObject(obj_parameters)
  ---- Create a scripting zone for the battlefield.
  --obj_parameters.type = 'ScriptingTrigger'
  --obj_parameters.position = {18.39, -4.00, -0.27}
  --obj_parameters.rotation = {0.00, 0.00, 0.00}
  --obj_parameters.scale = {4.60, 5.10, 3.40}
  --redBattlefieldZone = spawnObject(obj_parameters)
  -- Create a scripting zone for the mat.
  obj_parameters.type = 'ScriptingTrigger'
  obj_parameters.position = {-4.82, -4.00, -10.20}
  obj_parameters.rotation = {0.00, 0.00, 0.00}
  obj_parameters.scale = {41.22, 1.00, 12.46}
  redMatZone = spawnObject(obj_parameters)

  if Global.getVar("boardStyle") == "board_super_black" then
    redBoardsPrefab = setupObject.takeObject({position={20.85, -3.00, -10.05}, rotation={0,0,0}, guid=Global.getVar("redBoardsBlackGuid"), flip=false, smooth=false})
  else
    redBoardsPrefab = setupObject.takeObject({position={20.85, -3.00, -10.05}, rotation={0,0,0}, guid=Global.getVar("redBoardsTransparentGuid"), flip=false, smooth=false})
  end
  redBoardsPrefab.use_gravity = false
  redBoardsPrefab.interactable = false
  redBoardsPrefab.setLock(true)
  redBoardsPrefab.setName("Red")
  redBoardsPrefab.tooltip = false
  redBoardsPrefab.setLuaScript(modernBoardsScript)
  --redBoardsPrefab.createButton({
  --  click_function="redClaimBattlefield", function_owner=Global,
  --  position={2.56, 0.14, 6.89}, width=1400, height=720, font_size=72, color={0,0,0,0}
  --})

  coroutine.yield(0)
  coroutine.yield(0)

  Wait.time(movePlayerBoards, 0.5)

  setupObject.destruct()
  self.destruct()

  --if starterGame == true then
  --  startLuaCoroutine(self, 'spawnStarter')
  --end

  return 1
end


modernBoardsScript = [=[
function onload()
  -- Load inside the script since global images do not work for players who join late.
  local resourceAssets = {
    {
      name = "ingame_gui_background",
      url = "http://cloud-3.steamusercontent.com/ugc/948454725666385380/A47369F346253BDE02F44153C4940D47AA0E6E67/"
    },
    {
      name = "ingame_blue_panel_overlay",
      url = "http://cloud-3.steamusercontent.com/ugc/948454725666384731/E921F14A80CFA7C3BC20C7D7C61D7319443D0169/"
    },
    {
      name = "ingame_red_panel_overlay",
      url = "http://cloud-3.steamusercontent.com/ugc/948454725666389779/69DCF9BD43E89F93351F7F2F8E87D5CFFD7E3EF7/"
    },
    {
      name = "ingame_gui_maximize",
      url = "http://cloud-3.steamusercontent.com/ugc/948454725666387411/82FAD658AECC1F80A3413BEB32A2971FF168E4BF/"
    },
    {
      name = "ingame_gui_shuffle",
      url = "http://cloud-3.steamusercontent.com/ugc/948454725666389375/842D3237A768D7171668FCD28264F81C30BFEE0D/"
    },
    {
      name = "ingame_gui_discard",
      url = "http://cloud-3.steamusercontent.com/ugc/948454725666386672/85210903AED7A7F638BA6784A45A042013DD28FC/"
    }
  }
  self.UI.setCustomAssets(resourceAssets)

  tokenplayerone = Global.getTable('tokenplayerone')
  tokenplayertwo = Global.getTable('tokenplayertwo')

  if self.getName() == 'Blue' then
    owner = 'Blue'
  else
    owner = 'Red'
  end

  if owner == 'Blue' then
    self.UI.setXml([[
<Panel
   id="blue_panel"
   visibility="Blue"
   active="false"
   position="0 -300 -5"
   rotation="0 0 0"
   scale="5.46 5.46"
   rectAlignment="MiddleCenter"
   width="80"
   height="96"
   image="ingame_gui_background"
   raycastTarget="false"
>
<Image
   offsetXY="0 34"
   width="80"
   height="24"
   image="ingame_blue_panel_overlay"
   raycastTarget="false"
></Image>
<Text
   id="blue_panel_red_cards"
   scale="0.3 0.3"
   offsetXY="-6 39"
   fontStyle="Bold"
   fontSize="36"
   color="#FFFFFF"
>0</Text>
<Text
   id="blue_panel_blue_cards"
   scale="0.3 0.3"
   offsetXY="-6 29"
   fontStyle="Bold"
   fontSize="36"
   color="#FFFFFF"
>0</Text>
<Button
   offsetXY="30 56"
   width="10"
   height="10"
   onClick="Global/guiToggle"
   image="ingame_gui_maximize"
></Button>
<Button
   offsetXY="-18 -28"
   width="28"
   height="28"
   onClick="Global/guiShuffle"
   image="ingame_gui_shuffle"
></Button>
<Button
   offsetXY="18 -28"
   width="28"
   height="28"
   onClick="Global/guiDiscard"
   image="ingame_gui_discard"
   fontSize="32"
   textColor="#000000"
></Button>
</Panel>
]])
  else
    self.UI.setXml([[
<Panel
   id="red_panel"
   visibility="Red"
   active="false"
   position="0 -300 -5"
   rotation="0 0 0"
   scale="5.46 5.46"
   rectAlignment="MiddleCenter"
   width="80"
   height="96"
   image="ingame_gui_background"
   raycastTarget="false"
>
<Image
   offsetXY="0 34"
   width="80"
   height="24"
   image="ingame_red_panel_overlay"
   raycastTarget="false"
></Image>
<Text
   id="red_panel_blue_cards"
   scale="0.3 0.3"
   offsetXY="-6 39"
   fontStyle="Bold"
   fontSize="36"
   color="#FFFFFF"
>0</Text>
<Text
   id="red_panel_red_cards"
   scale="0.3 0.3"
   offsetXY="-6 29"
   fontStyle="Bold"
   fontSize="36"
   color="#FFFFFF"
>0</Text>
<Button
   offsetXY="30 56"
   width="10"
   height="10"
   onClick="Global/guiToggle"
   image="ingame_gui_maximize"
></Button>
<Button
   offsetXY="-18 -28"
   width="28"
   height="28"
   onClick="Global/guiShuffle"
   image="ingame_gui_shuffle"
></Button>
<Button
   offsetXY="18 -28"
   width="28"
   height="28"
   onClick="Global/guiDiscard"
   image="ingame_gui_discard"
   fontSize="32"
   textColor="#000000"
></Button>
</Panel>
]])
  end

  resourceSpawnIndex = 0
  discardCounter = 0
end

--function passButton()
--  if owner == 'Blue' then
--    broadcastToAll('Pass', {0.1,0.5,1.0})
--  else
--    broadcastToAll('Pass', {0.8,0.1,0.1})
--  end
--end

--function resourceSpawned(newResource)
--  newResource.setName("1 resource")
--  newResource.tooltip = false
--end

--function spawnResource()
--  local zoneObject = nil
--  local zonePosition = {}
--  local spawnReference = {x=0, y=0, z=0}
--  local obj_parameters = {}
--  local custom = {}
--  local token = nil
--  local xFactor = 1
--  local zFactor = 1
--
--  if owner == 'Blue' then
--    zoneObject = Global.getVar("blueResourceZone")
--    if (zoneObject != nil) then
--      zonePosition = zoneObject.getPosition()
--      spawnReference = {x = (zonePosition.x + 1.54), y = (zonePosition.y - 1.00), z = (zonePosition.z + 1.29)}
--    end
--
--    xFactor = (-1)
--    zFactor = (-1)
--  else
--    zoneObject = Global.getVar("redResourceZone")
--    if (zoneObject != nil) then
--      zonePosition = zoneObject.getPosition()
--      spawnReference = {x = (zonePosition.x - 1.54), y = (zonePosition.y - 1.00), z = (zonePosition.z - 1.29)}
--    end
--
--    xFactor = 1
--    zFactor = 1
--  end
--
--  obj_parameters.type = 'Custom_Token'
--  obj_parameters.callback_function = resourceSpawned
--  obj_parameters.position = {}
--  obj_parameters.position.x = (spawnReference.x + (xFactor * (resourceSpawnIndex % 4)))
--  obj_parameters.position.y = spawnReference.y
--  obj_parameters.position.z = (spawnReference.z + (zFactor * math.floor(resourceSpawnIndex / 4)))
--  obj_parameters.rotation = {0,0,0}
--
--  custom.image = tokenplayerone.resource
--  custom.thickness = 0.1
--  custom.merge_distance = 5.0
--  custom.stackable = false
--
--  token = spawnObject(obj_parameters)
--  token.setCustomObject(custom)
--  token.scale {0.23, 1.00, 0.23}
--
--  resourceSpawnIndex = (resourceSpawnIndex + 1)
--  if resourceSpawnIndex >= 20 then
--    resourceSpawnIndex = 0
--  end
--end

function randomDiscard()
  local handObjects = Player[owner].getHandObjects()
  local numHandObjects = #handObjects
  local discardPosition = {}
  local cardChoice = nil

  if numHandObjects > 0 then
    cardChoice = math.random(numHandObjects)

    if owner == 'Blue' then
      discardPosition.x = (-26.29)
      discardPosition.y = 2.20
      discardPosition.z = (6.59 + discardCounter)
    else
      discardPosition.x = 26.29
      discardPosition.y = 2.20
      discardPosition.z = ((-6.59) - discardCounter)
    end

    -- Teleport first to avoid the hand zone grabbing the card back.
    handObjects[cardChoice].setPosition(discardPosition)
    -- Now move fast with no collision using smooth motion so that the card will fall.
    discardPosition.y = (discardPosition.y - 0.20)
    handObjects[cardChoice].setPositionSmooth(discardPosition, false, true)

    discardCounter = (discardCounter + 1)
    if discardCounter >= 5 then
      discardCounter = 0
    end
  end
end

function shuffleHand()
  local handObjects = Player[owner].getHandObjects()
  local numHandObjects = #handObjects
  local cardPositions = {}

  if numHandObjects > 0 then
    for i, v in pairs(handObjects) do
        cardPositions[i] = v.getPosition()
    end
    local handObjectsShuffled = shuffleTable(handObjects)
    local cardPositionsShuffled = shuffleTable(cardPositions)
    for i, v in pairs(handObjectsShuffled) do
        v.setPosition(cardPositionsShuffled[i])
    end
  end
end

function shuffleTable(t)
    for i = #t, 2, -1 do
        local n = math.random(i)
        t[i], t[n] = t[n], t[i]
    end
    return t
end

function onDrop(playerColor)
  local objectPosition = self.getPosition()
  --local battlefieldZone = nil
  --local resourceZone = nil
  local matZone = nil

  -- Update zones to match the board position.

  if (owner == 'Blue') then
    --battlefieldZone = Global.getVar("blueBattlefieldZone")
    --resourceZone = Global.getVar("blueResourceZone")
    matZone = Global.getVar("blueMatZone")

    --if battlefieldZone != nil then
    --  battlefieldZone.setPosition({x = (objectPosition.x + 2.43), y = (objectPosition.y + 1.50), z = (objectPosition.z - 9.73)})
    --end
    --
    --if resourceZone != nil then
    --  resourceZone.setPosition({x = (objectPosition.x - 2.18), y = (objectPosition.y + 1.50), z = (objectPosition.z - 9.68)})
    --end

    if matZone != nil then
      matZone.setPosition({x = (objectPosition.x + 25.64), y = (objectPosition.y + 2.50), z = (objectPosition.z + 0.20)})
    end
  else
    --battlefieldZone = Global.getVar("redBattlefieldZone")
    --resourceZone = Global.getVar("redResourceZone")
    matZone = Global.getVar("redMatZone")

    --if battlefieldZone != nil then
    --  battlefieldZone.setPosition({x = (objectPosition.x - 2.43), y = (objectPosition.y + 1.50), z = (objectPosition.z + 9.73)})
    --end
    --
    --if resourceZone != nil then
    --  resourceZone.setPosition({x = (objectPosition.x + 2.18), y = (objectPosition.y + 1.50), z = (objectPosition.z + 9.68)})
    --end

    if matZone != nil then
      matZone.setPosition({x = (objectPosition.x - 25.64), y = (objectPosition.y + 2.50), z = (objectPosition.z - 0.20)})
    end
  end
end

function handlePossibleBotSpawn(params)
  local position = self.getPosition()
  local object = params.cardObject
  local obj_parameters = {}
  local custom = {}
  obj_parameters.scale = {1.7,1.7,1.7}
  obj_parameters.position = {object.getPosition()[1],object.getPosition()[2]+1,object.getPosition()[3]}
  obj_parameters.rotation = {0,object.getRotation()[2]+180,0}

  if ((object.getVar("spawned") ~= true) and
      (object.tag == 'Card') and
      (Global.getVar("loadDelayFinished") == true)) then
    local isBotCard = false
    local cardDescription = object.getDescription()
    local cardDescriptionLength = 0
    local testCardType = nil

    print(cardDescription)

    if cardDescription == 'Bot' then
      isBotCard = true
    end

    -- For bot cards, create XML GUI
    if (isBotCard == true) then
      -- Since attaching the GUI directly to the card would cause the GUI to rotate when the card rotates, use a GUI holder object.
      obj_parameters.type = 'BlockSquare'
      obj_parameters.position = {object.getPosition()[1], 0.02, object.getPosition()[3]}
      if (owner == 'Blue') then
        obj_parameters.rotation = {0, 0, 0}
      else
        obj_parameters.rotation = {0, 180, 0}
      end
      obj_parameters.scale = {1, 1, 1}
      obj_parameters.sound = false
      -- Note that both the bot card and the GUI holder objects have scripts.
      obj_parameters.callback_function = function(newObject) initGUIHolder(object, newObject) end

      local cardGUIObject = spawnObject(obj_parameters)
    end
  else
    local linkedGUIHolder = object.getVar("linkedGUIHolder")

    -- If a GUI holder was linked and hidden, show it.
    if (linkedGUIHolder != nil) then
      -- Update the position.
      local cardPosition = object.getPosition()
      linkedGUIHolder.setPosition({x = cardPosition.x, y = 0.02, z = cardPosition.z})

      if (linkedGUIHolder.UI.getAttribute("card_gui", "active") == "False") then
        linkedGUIHolder.UI.setAttribute("card_gui", "active", true)
        linkedGUIHolder.UI.setAttribute("opponent_card_gui", "active", true)

        -- Update the visibility to match the prefab owner.
        if (owner == 'Blue') then
          linkedGUIHolder.setRotation({0, 0, 0})
        else
          linkedGUIHolder.setRotation({0, 180, 0})
        end
        linkedGUIHolder.UI.setAttribute("card_gui", "visibility", owner)
        if (owner == 'Blue') then
          linkedGUIHolder.UI.setAttribute("opponent_card_gui", "visibility", 'Red|Grey|Black')
        else
          linkedGUIHolder.UI.setAttribute("opponent_card_gui", "visibility", 'Blue|Grey|Black')
        end
      end
    end
  end
end

function initGUIHolder(cardObject, holderObject)
  -- Set shield and damage values.
  -- TODO is there a way to save/load variables on objects like this?
  holderObject.setVar("shields", 0)
  holderObject.setVar("damage", 0)
  holderObject.setVar("owner", owner)

  holderObject.setLuaScript(Global.getVar("characterGUILuaScript"))
  Wait.time(function() finishInitGUIHolder(cardObject, holderObject) end, 0.2)

  cardObject.setVar("linkedGUIHolder", holderObject)
end

function finishInitGUIHolder(cardObject, holderObject)
  holderObject.UI.setAttribute("card_gui", "visibility", owner)
  holderObject.UI.setAttribute("card_gui", "active", true)
  if (owner == 'Blue') then
    holderObject.UI.setAttribute("opponent_card_gui", "visibility", 'Red|Grey|Black')
  else
    holderObject.UI.setAttribute("opponent_card_gui", "visibility", 'Blue|Grey|Black')
  end
  holderObject.UI.setAttribute("opponent_card_gui", "active", true)
end
]=]


function classicMenu(player)
  Global.setVar("mainMenuPanelOpen", false)
  Global.UI.setAttribute("main_menu_panel", "active", false)
  player.lookAt({ position={0,0,0}, pitch=62, yaw=180, distance=20})
end

function clearSpawnedItems()
  for i in ipairs(spawnditems) do
    if getObjectFromGUID(spawnditems[i]) != nil then
      getObjectFromGUID(spawnditems[i]).destruct()
    end
  end
  spawnditems={}
end

--function generatePacksAwakenings(buttonObject, playerColor)
--  generatePacks(playerColor, 'AW')
--end
--
--function generatePacksSpirit(buttonObject, playerColor)
--  generatePacks(playerColor, 'SoR')
--end
--
--function generatePacksEmpire(buttonObject, playerColor)
--  generatePacks(playerColor, 'EaW')
--end
--
--function generatePacksLegacies(buttonObject, playerColor)
--  generatePacks(playerColor, 'LEG')
--end
--
--function generatePacksWay(buttonObject, playerColor)
--  generatePacks(playerColor, 'WotF')
--end
--
--function generateMixedPacks(buttonObject, playerColor)
--  generatePacks(playerColor, 'Mixed')
--end
--
--function readyForRivals()
--  rivalsDummyCard.destruct()
--
--  startLuaCoroutine(self, 'spawnRivalsCards')
--end

--function draftReadyForDeal(oldAllCardsDeck)
--  local mixedPacksDeck = nil
--
--  -- If not cube drafting, destruct the old deck that had all Destiny cards in it.
--  if rivalsExpansion != 'Cube' then
--    oldAllCardsDeck.destruct()
--    oldAllCardsDeck = nil
--  end
--
--  -- Find the mixed packs deck and make it uninteractable.
--  local scriptZoneObjects = draftOriginDeckZone.getObjects()
--  for deckIndex,curDeck in ipairs(scriptZoneObjects) do
--    if curDeck.tag == "Deck" then
--      mixedPacksDeck = curDeck
--      mixedPacksDeck.interactable = false
--      mixedPacksDeck.setLock(true)
--      break
--    end
--  end
--
--  -- Make the table of pack selections available so the main game script can use it.
--  Global.setTable("packSelections", packSelections)
--  -- Set up a table of expansion indices for dealing cards.
--  Global.setTable("nextExpansionIndex", nextExpansionIndex)
--  -- Make the table of packs available so the main game script can use it.
--  Global.setTable("rivalsExpansionPacks", rivalsExpansionPacks)
--  -- Set a reference to the deck so the main game script can use and destruct it.
--  Global.setVar("mixedPacksDeck", mixedPacksDeck)
--  -- Set whether the cube compatibility mode is active.
--  Global.setVar("cubeCompatibilityMode", cubeCompatibilityMode)
--
--  -- Deal cards.
--  printToAll("Dealing cards...", {1,1,1})
--  Global.call("draftReadyForDeal")
--
--  -- The menu is no longer needed.
--  self.destruct()
--end

--function draftZoneReady()
--  local databank = Global.getTable("cardstable")
--  local rarity
--  local index
--  spawnd = 0
--  cardPulledCount = 0
--
--  -- Move the script zone for the draft origin deck.
--  draftOriginDeckZone.setPosition({6,2,-0.5})
--
--  if rivalsExpansion != 'Cube' then
--    -- Pull a deck that contains all draft/sealed cards.
--    setupObject.takeObject({position={6,2,6}, rotation={0,0,180}, guid=allCardsDeckGuid, flip=false, smooth=false, callback='allCardsDeckPulled', callback_owner=self})
--  else
--    -- For a cube, the deck is already available.
--    allCardsDeckPulled(cubeDeck)
--  end
--end

--function spawnRivalsCards()
--  coroutine.yield(0)
--
--  -- Pull the Rivals deck.
--  setupObject.takeObject({position={14,2.0,-0.9}, rotation={0,0,0}, guid=rivalsDeckGuid, flip=false, smooth=false})
--
--  -- Create a script zone for the dummy card plus the cube deck.  This is created under the table to avoid a white flash.
--  local obj_parameters = {}
--
--  obj_parameters.type = 'ScriptingTrigger'
--  obj_parameters.scale = { 5.0, 5.0, 6.0 }
--  obj_parameters.position = { 6.000,-4.000, 0.500 }
--  obj_parameters.rotation = { 0.000, 0.000, 0.000 }
--  draftOriginDeckZone = spawnObject(obj_parameters)
--
--  -- Sleep briefly to let the draft zone spawn.
--  Wait.time(draftZoneReady, 0.5)
--
--  return 1
--end

--function spawndb()
--  for i in ipairs(spawnditems) do
--    if getObjectFromGUID(spawnditems[i]) != nil then
--      getObjectFromGUID(spawnditems[i]).destruct()
--    end
--  end
--  spawnditems={}
--  startLuaCoroutine(self, 'spawnDeckbuilding')
--end

--function spawnDeckbuilding()
--  coroutine.yield(0)
--  local object = getObjectFromGUID('1cc719').clone({position={28,1,20}})
--  coroutine.yield(0)
--  --getObjectFromGUID('a47a8c').takeObject({position={28,1,-8}})
--  cards = {}
--  cards = object.getObjects()
--  spawnCards(cards,object)
--  return 1
--end
--
--function searchCardinDB(card)
--  local databank = Global.getTable("cardstable")
--  for i in ipairs(databank) do
--    if databank[i]["cardname"] == card then
--      return i
--    end
--  end
--  return false
--end
--
--function spawnCards(cards,object)
--  local databank = Global.getTable("cardstable")
--  spawnd = 1
--  height = 0
--  for i in ipairs(cards) do
--    index = searchCardinDB(cards[i].nickname)
--    if index != false then
--      if databank[index]["affiliation"] == affiliationselect or databank[index]["affiliation"] == affiliationselect2 or databank[index]["affiliation"] == affiliationselect3 then
--        if databank[index]["type"] == typeselect or databank[index]["type"] == typeselect2 or databank[index]["type"] == typeselect3 or databank[index]["type"] == typeselect4 then
--          if databank[index]["color"] == colorselect or databank[index]["color"] == colorselect2 or databank[index]["color"] == colorselect3 or databank[index]["color"] == colorselect4 then
--            if spawnd==164 then coroutine.yield(0) getObjectFromGUID(cards[i].guid).setPosition({27.5-((spawnd-150)*3.5),1,22.5}) table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({-27.5,1,24.5}) height=0 end
--            if spawnd<164 and spawnd>150 then object.takeObject({position={27.5-((spawnd-150)*3.5),1,22.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({-27.5,1,24.5}) height=0 end
--            if spawnd<151 and spawnd>135 then object.takeObject({position={27.5-((spawnd-135)*3.5),1,17.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,24.5}) height=1 end
--            if spawnd<136 and spawnd>120 then object.takeObject({position={27.5-((spawnd-120)*3.5),1,12.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,19.5}) height=2 end
--            if spawnd<121 and spawnd>105 then object.takeObject({position={27.5-((spawnd-105)*3.5),1,7.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,14.5}) height=3 end
--            if spawnd<106 and spawnd>90 then object.takeObject({position={27.5-((spawnd-90)*3.5),1,2.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,9.5}) height=4 end
--            if spawnd<91 and spawnd>75 then object.takeObject({position={27.5-((spawnd-75)*3.5),1,-2.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,4.5}) height=5  end
--            if spawnd<76 and spawnd>60 then object.takeObject({position={27.5-((spawnd-60)*3.5),1,-7.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,-0.5}) height=6 end
--            if spawnd<61 and spawnd>45 then object.takeObject({position={27.5-((spawnd-45)*3.5),1,-12.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,-5.5}) height=7 end
--            if spawnd<46 and spawnd>30 then object.takeObject({position={27.5-((spawnd-30)*3.5),1,-17.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,-10.5}) height=8 end
--            if spawnd<31 and spawnd>15 then object.takeObject({position={27.5-((spawnd-15)*3.5),1,-22.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,-15.5}) height=9 end
--            if spawnd<16 then object.takeObject({position={27.5-(spawnd*3.5),1,-27.5},guid=cards[i].guid}) spawnd=spawnd+1 table.insert(spawnditems, cards[i].guid) getObjectFromGUID('2a325b').setPosition({21.5,1,-20.5}) height=10  end
--          end
--        end
--      end
--    end
--
--
--  end
--
--  if battlefieldbutton == true then
--    local battlefield = getObjectFromGUID('cf8e15').clone({position={28,1,-1.5}})
--    battlefieldcards = battlefield.getObjects()
--    for i in ipairs (battlefieldcards) do
--      if i==10 then coroutine.yield(0) getObjectFromGUID(battlefieldcards[i].guid).setPosition({29-(i*5),1,27-(height*5)}) getObjectFromGUID(battlefieldcards[i].guid).setRotation({0,-90,0}) table.insert(spawnditems, battlefieldcards[i].guid) end
--      if i<10 then battlefield.takeObject({position={29-(i*5),1,27-(height*5)},rotation={0,-90,0},guid=battlefieldcards[i].guid}) table.insert(spawnditems, battlefieldcards[i].guid) if height != 0 then getObjectFromGUID('2a325b').setPosition({21.5,1,33.5-(height*5)}) end end
--    end
--    if battlefield != nil then battlefield.destruct() end
--  end
--  if object!= nil then object.destruct() end
--end

function mainMenu()
  self.clearButtons()
  --self.createButton({
  --  label='Starter Deck Game', click_function="setupStarter", function_owner=self,
  --  position={0,0.1,-0.3}, width=900, height=150, font_size=100
  --})

  self.createButton({
    label='2 Player Modern', click_function="twoPlayerModernFromClassic", function_owner=self,
    position={0,0.1,0}, width=900, height=150, font_size=100
  })

  self.createButton({
    label='2 Player Classic', click_function="twoPlayerClassic", function_owner=self,
    position={0,0.1,0.3}, width=900, height=150, font_size=100
  })

  --self.createButton({
  --  label='Normal Draft', click_function="setupDraftNormal", function_owner=self,
  --  position={0,0.1,0.6}, width=900, height=150, font_size=100
  --})
  --
  --self.createButton({
  --  label='Winchester Draft', click_function="setupDraftWinchester", function_owner=self,
  --  position={0,0.1,0.9}, width=900, height=150, font_size=100
  --})
  --
  --self.createButton({
  --  label='Cube Draft', click_function="setupDraftCube", function_owner=self,
  --  position={0,0.1,1.2}, width=900, height=150, font_size=100
  --})
  --
  --self.createButton({
  --  label='Sealed Game', click_function="setupSealed", function_owner=self,
  --  position={0,0.1,1.5}, width=900, height=150, font_size=100
  --})
end

--function setupStarter(buttonObject, playerColor)
--  -- Zoom camera back out to the normal perspective for that player.
--  zoomCameraBackOut(playerColor)
--
--  -- Delay slightly so camera movement does not feel too sudden.
--  Wait.time(function() setupStarterAfterDelay(playerColor) end, 0.2)
--end
--
--function setupStarterAfterDelay(playerColor)
--  red = 2
--  blue = 2
--  starterGame = true
--  startLuaCoroutine(self, 'spawnSetupCoroutine')
--end

--function spawnStarter()
--  setupObject.takeObject({position={11.9,2,-7.9},rotation={5,180,180},guid='086cb2'})
--  setupObject.takeObject({position={-11.9,2,7.9},rotation={5,360,180},guid='11ea1a'})
--  setupObject.takeObject({position={-2,2,8.4},guid='0a61f2'})
--  setupObject.takeObject({position={8.5,2,8.4},guid='5d54d1'})
--  setupObject.takeObject({position={2,2,-8.4},rotation={360,180,360},guid='ccf866'})
--  setupObject.takeObject({position={-8.5,2,-8.4},rotation={360,180,360},guid='48f820'})
--  setupObject.takeObject({position={-14,1,1.5}, rotation={360,270,360}, guid='05bfd4'})
--  setupObject.takeObject({position={14,1,-1.5}, rotation={360,90,360}, guid='499c42'})
--  setupObject.takeObject({position={-20,1,7.9}, rotation={360,0,360}, guid='5d3305'})
--  setupObject.takeObject({position={20,1,-7.9}, rotation={360,180,360}, guid='eafe7f'})
--  coroutine.yield(0)
--  coroutine.yield(0)
--  getObjectFromGUID('086cb2').shuffle()
--  getObjectFromGUID('11ea1a').shuffle()
--
--  return 1
--end

function twoPlayerClassic(buttonObject, playerColor)
  red = 0
  blue = 0

  self.clearButtons()

  self.createButton({
    label='Red: 1 Character',click_function="red1",function_owner=self,
    position={-0.9,0.1,-1.2},width = 800, height = 150, font_size = 90
  })

  self.createButton({
    label='Red: 2 Characters',click_function="red2",function_owner=self,
    position={-0.9,0.1,-0.9},width = 800, height = 150, font_size = 90
  })

  self.createButton({
    label='Red: 3 Characters',click_function="red3",function_owner=self,
    position={-0.9,0.1,-0.6},width = 800, height = 150, font_size = 90,
  })

  self.createButton({
    label='Red: 4 Characters',click_function="red4",function_owner=self,
    position={-0.9,0.1,-0.3},width = 800, height = 150, font_size = 90
  })

  self.createButton({
    label='Blue: 1 Character',click_function="blue1",function_owner=self,
    position={0.9,0.1,-1.2},width = 800, height = 150, font_size = 90
  })

  self.createButton({
    label='Blue: 2 Characters',click_function="blue2",function_owner=self,
    position={0.9,0.1,-0.9},width = 800, height = 150, font_size = 90
  })

  self.createButton({
    label='Blue: 3 Characters',click_function="blue3",function_owner=self,
    position={0.9,0.1,-0.6},width = 800, height = 150, font_size = 90,
  })

  self.createButton({
    label='Blue: 4 Characters',click_function="blue4",function_owner=self,
    position={0.9,0.1,-0.3},width = 800, height = 150, font_size = 90
  })

  self.createButton({
    label='Back',click_function="mainMenu",function_owner=self,
    position={1.3,0.1,1.5},width = 400, height = 150, font_size = 100
  })

  self.createButton({
    label='Spawn',click_function="spawnSetupButton",function_owner=self,
    position={-1.3,0.1,1.5},width = 400, height = 150, font_size = 100
  })
end

--function setupDraftNormal()
--  Global.setVar("rivalsMode", "Normal Draft")
--  setupPacksMenu()
--end
--
--function setupDraftWinchester()
--  Global.setVar("rivalsMode", "Winchester Draft")
--  setupPacksMenu()
--end
--
--function setupDraftCube()
--  Global.setVar("rivalsMode", "Cube Draft")
--  setupCubeMenu()
--end
--
--function setupSealed()
--  Global.setVar("rivalsMode", "Normal Sealed")
--  setupPacksMenu()
--end

--function setupCubeMenu()
--  -- Move the cube board and cube deck zone up.
--  cubeBoard.setPosition({-9.5,1,0})
--  cubeDeckZone.setPosition({-9.5,1,0})
--
--  self.clearButtons()
--
--  self.createButton({
--    label='Back',click_function="closeCubeMenu",function_owner=self,
--    position={1.3,0.1,1.6},width = 400, height = 150, font_size = 100
--  })
--
--  self.createButton({
--    label='Process Cube', click_function="processCube", function_owner=self,
--    position={0,0.1,0}, width=1400, height=500, font_size=200
--  })
--end

--function closeCubeMenu()
--  -- Hide the cube board and cube deck zone.
--  cubeBoard.setPosition({-9.5,-4,0})
--  cubeDeckZone.setPosition({-9.5,-4,0})
--
--  mainMenu()
--end

--function processCube(buttonObject, playerColor)
--  -- Zoom camera back out to the normal perspective for that player.
--  zoomCameraBackOut(playerColor)
--
--  -- Delay slightly so camera movement does not feel too sudden.
--  Wait.time(function() processCubeAfterDelay(playerColor) end, 0.2)
--end

--function processCubeAfterDelay(playerColor)
--  -- Move player mats up before things start dropping on them.
--  Global.call("moveAllMatsUp")
--
--  cubeDeck = nil
--  local scriptZoneObjects = cubeDeckZone.getObjects()
--  for i,curDeck in ipairs(scriptZoneObjects) do
--    if curDeck.tag == "Deck" then
--      cubeDeck = curDeck
--      break
--    end
--  end
--
--  -- Make sure the cube has enough cards.
--  if cubeDeck != nil then
--    local seatedPlayers = getSeatedPlayers()
--    local numSeatedPlayers = 0
--    for i,somePlayer in pairs(seatedPlayers) do
--      numSeatedPlayers = numSeatedPlayers + 1
--    end
--
--    -- Each player will need 6 packs of 5 cards each.
--    local cubeCards = #(cubeDeck.getObjects())
--    local minCubeCards = (numSeatedPlayers * 6 * 5)
--    if cubeCards < minCubeCards then
--      printToAll("Error, for " .. numSeatedPlayers .. " player(s), the cube must contain at least " .. minCubeCards .. " cards.", {1,0,0})
--      return
--    end
--  end
--
--  if cubeDeck != nil then
--    -- Spawn the "please wait" message board.
--    Global.call("showPleaseWait")
--
--    -- Get the rotation of the cube deck.
--    cubeDeckRotation = cubeDeck.getRotation()
--
--    -- Flip the deck upside down if needed.
--    if ((cubeDeckRotation.z < 160) or (cubeDeckRotation.z > 200)) then
--      cubeDeck.setRotation({0, 0, 180})
--    end
--
--    -- Process the cube cards and create packs.
--    createCubePacks()
--
--    self.setPosition({0, -4, 0})
--
--    clearSpawnedItems()
--    rivalsExpansion = 'Cube'
--
--    -- Delete the cube board and cube deck zone.
--    cubeBoard.destruct()
--    cubeDeckZone.destruct()
--
--    -- Go ahead and move the dummy card so that other cards will fall on top of it.
--    -- The move is done with no collision, and it is done fast.  Also, clone the
--    -- dummy card, so that if the cube is dealt out entirely, what is left will
--    -- still be a deck.
--    rivalsDummyCard.setLock(false)
--    rivalsDummyCard.clone({position={6,6,-0.9}})
--    rivalsDummyCard.clone({position={6,7,-0.9}})
--    rivalsDummyCard.setLock(true)
--
--    Global.call("initBoards")
--
--    -- The cube is moved after a small delay since otherwise it ends up crooked, probably because of the dummy cards.
--    Wait.time(handleCubeMove, 0.5)
--
--    printToAll("Processing cube...", {1,1,1})
--  else
--    printToAll("Error, please put a deck in the cube zone.", {1,0,0})
--  end
--end

--function handleCubeMove()
--  -- To fix a strange bug where other people hosting the mod fail to move the cube deck, teleport it first.
--  local cubeDeckPosition = cubeDeck.getPosition()
--  cubeDeck.setPosition({x = cubeDeckPosition.x, y = (cubeDeckPosition.y + 4), z = cubeDeckPosition.z})
--
--  -- Move the cube without collision and move it fast.
--  cubeDeck.drag = 0.001
--  cubeDeck.angular_drag = 0.001
--  cubeDeck.dynamic_friction = 0.8
--  cubeDeck.bounciness = 0
--  cubeDeck.interactable = false
--  cubeDeck.setPositionSmooth({6,3,-0.9}, false, true)
--
--  Wait.time(readyForRivals, 1.0)
--end

--function createCubePacks()
--  local databank = Global.getTable("cardstable")
--  local cubeObjects = cubeDeck.getObjects()
--
--  allExpansionLegendaries['Cube']   = {}
--  allExpansionRares['Cube']         = {}
--  allExpansionUncommons['Cube']     = {}
--  allExpansionCommons['Cube']       = {}
--
--  -- Process the cube to create lists of cards by rarity.
--  for cubeIndex,cubeCard in ipairs(cubeObjects) do
--    local cubeCardDescription = cubeCard.description
--
--    for index,curCard in ipairs(databank) do
--      local setAndNumber = (curCard["set"] .. ' ' .. curCard["number"])
--
--      if ((cubeCardDescription != nil) and (cubeCardDescription != '')) then
--        -- The new description format is used.
--        if (cubeCardDescription == setAndNumber) then
--          local rarity = curCard["rarity"]
--
--          if "Legendary" == rarity then
--            table.insert(allExpansionLegendaries['Cube'], setAndNumber)
--          elseif "Rare" == rarity then
--            table.insert(allExpansionRares['Cube'], setAndNumber)
--          elseif "Uncommon" == rarity then
--            table.insert(allExpansionUncommons['Cube'], setAndNumber)
--          elseif "Common" == rarity then
--            table.insert(allExpansionCommons['Cube'], setAndNumber)
--          else
--            -- Nothing needs done.
--          end
--
--          break
--        end
--      else
--        -- The old name system is used.
--        cubeCompatibilityMode = true
--        if cubeCard.nickname == curCard["cardname"] then
--          local rarity = curCard["rarity"]
--
--          if "Legendary" == rarity then
--            table.insert(allExpansionLegendaries['Cube'], cubeCard.nickname)
--          elseif "Rare" == rarity then
--            table.insert(allExpansionRares['Cube'], cubeCard.nickname)
--          elseif "Uncommon" == rarity then
--              table.insert(allExpansionUncommons['Cube'], cubeCard.nickname)
--          elseif "Common" == rarity then
--            table.insert(allExpansionCommons['Cube'], cubeCard.nickname)
--          else
--            -- Nothing needs done.
--          end
--
--          break
--        end
--      end
--
--    end
--  end
--
--  local expansionDiceCards  = {}
--  local expansionUncommons  = {}
--  local expansionCommons    = {}
--
--  local diceCards          = {}
--  local uncommonCards      = {}
--  local commonCards        = {}
--
--  -- Combine the legendaries and rares.
--  local numLegendaries = #(allExpansionLegendaries['Cube'])
--  local numRares = #(allExpansionRares['Cube'])
--  for legendaryIndex=1,numLegendaries do
--    table.insert(diceCards, allExpansionLegendaries['Cube'][legendaryIndex])
--  end
--  for rareIndex=1,numRares do
--    table.insert(diceCards, allExpansionRares['Cube'][rareIndex])
--  end
--
--  -- Make a copy of the uncommon and common tables.
--  local numUncommons = #(allExpansionUncommons['Cube'])
--  local numCommons = #(allExpansionCommons['Cube'])
--  for uncommonIndex=1,numUncommons do
--    table.insert(uncommonCards, allExpansionUncommons['Cube'][uncommonIndex])
--  end
--  for commonIndex=1,numCommons do
--    table.insert(commonCards, allExpansionCommons['Cube'][commonIndex])
--  end
--
--  -- Randomize the dice cards.
--  local totalDiceCards = (numLegendaries + numRares)
--  local diceCardsLeftToRandomize = totalDiceCards
--  for i=1,totalDiceCards do
--    local randomIndex = math.random(1,diceCardsLeftToRandomize)
--    table.insert(expansionDiceCards, table.remove(diceCards, randomIndex))
--    diceCardsLeftToRandomize = diceCardsLeftToRandomize - 1
--  end
--
--  -- Randomize the uncommon cards.
--  local totalUncommonCards = #(allExpansionUncommons['Cube'])
--  local uncommonCardsLeftToRandomize = totalUncommonCards
--  for i=1,totalUncommonCards do
--    local randomIndex = math.random(1,uncommonCardsLeftToRandomize)
--    table.insert(expansionUncommons, table.remove(uncommonCards, randomIndex))
--    uncommonCardsLeftToRandomize = uncommonCardsLeftToRandomize - 1
--  end
--
--  -- Randomize the common cards.
--  local totalCommonCards = #(allExpansionCommons['Cube'])
--  local commonCardsLeftToRandomize = totalCommonCards
--  for i=1,totalCommonCards do
--    local randomIndex = math.random(1,commonCardsLeftToRandomize)
--    table.insert(expansionCommons, table.remove(commonCards, randomIndex))
--    commonCardsLeftToRandomize = commonCardsLeftToRandomize - 1
--  end
--
--  -- Determine how many packs can be created.  Note that this may require substituting commons for uncommons or similar.
--  local numCubePacks = math.floor((totalDiceCards + totalUncommonCards + totalCommonCards) / 5)
--
--  local numDiceCardsLeft   = totalDiceCards
--  local numUncommonsLeft   = totalUncommonCards
--  local numCommonsLeft     = totalCommonCards
--  local nextDiceCardIndex  = 1
--  local nextUncommonIndex  = 1
--  local nextCommonIndex    = 1
--
--  -- At this point, all cards have been processed and randomized, so packs can be created.
--  rivalsExpansionPacks['Cube'] = {}
--  nextExpansionIndex['Cube'] = 1
--  for packIndex = 1,numCubePacks do
--    -- The packs are created in reverse order so that dice cards end up on top of decks.
--    for cardIndex=1,3 do
--      if numCommonsLeft > 0 then
--        table.insert(rivalsExpansionPacks['Cube'], expansionCommons[nextCommonIndex])
--        nextCommonIndex = nextCommonIndex + 1
--        numCommonsLeft = numCommonsLeft - 1
--      elseif numUncommonsLeft > 0 then
--        -- Substitute uncommons for commons.
--        table.insert(rivalsExpansionPacks['Cube'], expansionUncommons[nextUncommonIndex])
--        nextUncommonIndex = nextUncommonIndex + 1
--        numUncommonsLeft = numUncommonsLeft - 1
--      elseif numDiceCardsLeft > 0 then
--        -- Substitute rares/legendaries for uncommons.
--        table.insert(rivalsExpansionPacks['Cube'], expansionDiceCards[nextDiceCardIndex])
--        nextDiceCardIndex = nextDiceCardIndex + 1
--        numDiceCardsLeft = numDiceCardsLeft - 1
--      else
--        printToAll("Error, not enough cards in cube.", {1,0,0})
--        Global.call("cleanupTable")
--        return
--      end
--    end
--
--    if numUncommonsLeft > 0 then
--      table.insert(rivalsExpansionPacks['Cube'], expansionUncommons[nextUncommonIndex])
--      nextUncommonIndex = nextUncommonIndex + 1
--      numUncommonsLeft = numUncommonsLeft - 1
--    elseif numCommonsLeft > 0 then
--      -- Substitute commons for uncommons.
--      table.insert(rivalsExpansionPacks['Cube'], expansionCommons[nextCommonIndex])
--      nextCommonIndex = nextCommonIndex + 1
--      numCommonsLeft = numCommonsLeft - 1
--    elseif numDiceCardsLeft > 0 then
--      -- Substitute rares/legendaries for commons.
--      table.insert(rivalsExpansionPacks['Cube'], expansionDiceCards[nextDiceCardIndex])
--      nextDiceCardIndex = nextDiceCardIndex + 1
--      numDiceCardsLeft = numDiceCardsLeft - 1
--    else
--      printToAll("Error, not enough cards in cube.", {1,0,0})
--      Global.call("cleanupTable")
--      return
--    end
--
--    if numDiceCardsLeft > 0 then
--      table.insert(rivalsExpansionPacks['Cube'], expansionDiceCards[nextDiceCardIndex])
--      nextDiceCardIndex = nextDiceCardIndex + 1
--      numDiceCardsLeft = numDiceCardsLeft - 1
--    elseif numUncommonsLeft > 0 then
--      -- Substitute uncommons for rares/legendaries.
--      table.insert(rivalsExpansionPacks['Cube'], expansionUncommons[nextUncommonIndex])
--      nextUncommonIndex = nextUncommonIndex + 1
--      numUncommonsLeft = numUncommonsLeft - 1
--    elseif numCommonsLeft > 0 then
--      -- Substitute commons for uncommons.
--      table.insert(rivalsExpansionPacks['Cube'], expansionCommons[nextCommonIndex])
--      nextCommonIndex = nextCommonIndex + 1
--      numCommonsLeft = numCommonsLeft - 1
--    else
--      printToAll("Error, not enough cards in cube.", {1,0,0})
--      Global.call("cleanupTable")
--      return
--    end
--  end
--end

--function setupPacksMenu()
--  local rivalsMode = Global.getVar("rivalsMode")
--
--  if rivalsMode == "Winchester Draft" then
--    numPacksPerPlayer = 8
--  elseif rivalsMode == "Normal Sealed" then
--    numPacksPerPlayer = 8
--  else
--    numPacksPerPlayer = 6
--  end
--
--  packSelectButtons = nil
--
--  self.clearButtons()
--
--  self.createButton({
--    label='Back',click_function="mainMenu",function_owner=self,
--    position={1.3,0.1,1.6},width = 400, height = 150, font_size = 100
--  })
--
--  self.createButton({
--    label='Awakenings', click_function="generatePacksAwakenings", function_owner=self,
--    position={0,0.1,-0.9}, width=1100, height=150, font_size=100
--  })
--
--  self.createButton({
--    label='Spirit of Rebellion',click_function="generatePacksSpirit",function_owner=self,
--    position={0,0.1,-0.6}, width=1100, height=150, font_size=100
--  })
--
--  self.createButton({
--    label='Empire at War',click_function="generatePacksEmpire",function_owner=self,
--    position={0,0.1,-0.3}, width=1100, height=150, font_size=100
--  })
--
--  self.createButton({
--    label='Legacies',click_function="generatePacksLegacies",function_owner=self,
--    position={0,0.1,0}, width=1100, height=150, font_size=100
--  })
--
--  self.createButton({
--    label='Way of the Force',click_function="generatePacksWay",function_owner=self,
--    position={0,0.1,0.3}, width=1100, height=150, font_size=100
--  })
--
--  self.createButton({
--    label='Mix Expansions',click_function="mixExpansionsMenu",function_owner=self,
--    position={0,0.1,0.9}, width=1100, height=150, font_size=100
--  })
--end

--function mixExpansionsMenu()
--  local offsetX = (-1.4)
--  local offsetY = (0.1)
--  local offsetZ = (-1.2)
--
--  self.clearButtons()
--
--  -- Create buttons for each expansion.
--  for i=1,numPacksPerPlayer do
--    self.createButton({
--      label='AW', click_function="packAW"..i, function_owner=self,
--      position={ offsetX + 0.0, offsetY, (offsetZ + (i*0.3)) }, width=320, height=150, font_size=100, color={0,0,0}, font_color={1,1,1}
--    })
--
--    self.createButton({
--      label='SoR',click_function="packSoR"..i,function_owner=self,
--      position={ offsetX + 0.7, offsetY, (offsetZ + (i*0.3)) }, width=320, height=150, font_size=100, color={0,0,0}, font_color={1,1,1}
--    })
--
--    self.createButton({
--      label='EaW',click_function="packEaW"..i,function_owner=self,
--      position={ offsetX + 1.4, offsetY, (offsetZ + (i*0.3)) }, width=320, height=150, font_size=100, color={0,0,0}, font_color={1,1,1}
--    })
--
--    self.createButton({
--      label='LEG',click_function="packLEG"..i,function_owner=self,
--      position={ offsetX + 2.1, offsetY, (offsetZ + (i*0.3)) }, width=320, height=150, font_size=100, color={0,0,0}, font_color={1,1,1}
--    })
--
--    self.createButton({
--      label='WotF',click_function="packWotF"..i,function_owner=self,
--      position={ offsetX + 2.8, offsetY, (offsetZ + (i*0.3)) }, width=320, height=150, font_size=100, color={1,1,1}, font_color={0,0,0}
--    })
--  end
--
--  -- Create buttons that just act as labels.
--  for i=1,numPacksPerPlayer do
--    self.createButton({
--      label=i, click_function="doNothing", function_owner=self,
--      position={-2.0, 0.1, ((-1.2)+(i*0.3))}, width=0, height=0, font_size=100, color={0,0,0}, font_color={1,1,1}
--    })
--  end
--
--  self.createButton({
--    label='Play',click_function="generateMixedPacks",function_owner=self,
--    position={-1.3,0.1,1.7}, width=400, height=150, font_size=100
--  })
--
--  self.createButton({
--    label='Back',click_function="setupPacksMenu",function_owner=self,
--    position={1.3,0.1,1.7}, width=400, height=150, font_size=100
--  })
--
--  -- Get all the buttons for quick access later.
--  packSelectButtons = self.getButtons()
--end

function doNothing()
end

--function generatePacks(playerColor, expansion)
--  -- Zoom camera back out to the normal perspective for that player.
--  zoomCameraBackOut(playerColor)
--
--  -- Move player mats up before things start dropping on them.
--  Global.call("moveAllMatsUp")
--
--  local rivalsMode = Global.getVar("rivalsMode")
--
--  -- Lock and make the decks uninteractable so players cannot cheat.  Also move them into the sky so no one can see them.
--  -- Move them to the side so they do not cause a reflection on the table.
--  -- It is important to keep them loaded, because otherwise when cards start getting pulled for dealing, huge loading
--  -- delays can result that may break draft timing.
--  local deckToLock = nil
--  local oldPosition = nil
--
--  deckToLock = getObjectFromGUID(awakeningsCycleDeckGuid)
--  if deckToLock != nil then
--    deckToLock.locked = true
--    deckToLock.interactable = false
--    oldPosition = deckToLock.getPosition()
--    deckToLock.setPosition({(oldPosition.x - 10), (oldPosition.y + 160), oldPosition.z})
--  end
--
--  deckToLock = getObjectFromGUID(legaciesCycleDeckGuid)
--  if deckToLock != nil then
--    deckToLock.locked = true
--    deckToLock.interactable = false
--    oldPosition = deckToLock.getPosition()
--    deckToLock.setPosition({(oldPosition.x - 10), (oldPosition.y + 160), oldPosition.z})
--  end
--
--  -- Sanity check player count before starting Winchester mode.
--  if rivalsMode == "Winchester Draft" then
--    local seatedPlayers = getSeatedPlayers()
--    local numSeatedPlayers = 0
--    for i,somePlayer in pairs(seatedPlayers) do
--      numSeatedPlayers = numSeatedPlayers + 1
--    end
--
--    if ((numSeatedPlayers == 1) or (numSeatedPlayers == 2)) then
--      local firstPlayerToAssign = nil
--      local secondPlayerToAssign = nil
--      local blueUsed = false
--      local greenUsed = false
--      local colorChangeNeeded = false
--      for i,somePlayer in pairs(seatedPlayers) do
--        if somePlayer == "Blue" then
--          blueUsed = true
--        elseif somePlayer == "Green" then
--          greenUsed = true
--        else
--          if firstPlayerToAssign == nil then
--            firstPlayerToAssign = somePlayer
--            colorChangeNeeded = true
--          else
--            secondPlayerToAssign = somePlayer
--            colorChangeNeeded = true
--          end
--        end
--      end
--
--      -- If either or both players are not blue/green, change their color(s).
--
--      if firstPlayerToAssign != nil then
--        if blueUsed == false then
--          Player[firstPlayerToAssign].changeColor("Blue")
--          blueUsed = true
--        else
--          -- If blue is used, then green must not be used, otherwise firstPlayerToAssign would be nil.
--          Player[firstPlayerToAssign].changeColor("Green")
--          greenUsed = true
--        end
--      end
--
--      if secondPlayerToAssign != nil then
--        -- If neither player was blue or green, the first player got assigned to blue, so this one should be green.
--        Player[secondPlayerToAssign].changeColor("Green")
--        greenUsed = true
--      end
--
--      if colorChangeNeeded == true then
--        printToAll("Winchester draft only uses the Blue and Green seats.", {1,1,1})
--      end
--    else
--      printToAll("Error, Winchester draft only supports 2 seated players.", {1,0,0})
--
--      return
--    end
--  end
--
--  self.setPosition({0, -4, 0})
--  clearSpawnedItems()
--  rivalsExpansion = expansion
--
--  -- Spawn the "please wait" message board.
--  Global.call("showPleaseWait")
--
--  -- Report progress.
--  printToAll("Preparing to generate expansion cards...", {1,1,1})
--
--  -- Spawn boards and get ready to continue setup.
--  Global.call("initBoards")
--  Wait.time(readyForRivals, 1.0)
--end

--function generateBoxes()
--  printToAll("Generating boxes...", {1,1,1})
--
--  -- Generate 6 legendaries and 30 rares for each box.
--  for i,curExpansion in pairs(expansions) do
--    local expansionDiceCards  = {}
--    local expansionUncommons  = {}
--    local expansionCommons    = {}
--
--    for boxIndex=1,2 do
--      local boxDiceCards = {}
--      local randomIndex = 1
--      local numBoxLegendaries = 0
--
--      -- Prevent duplicate legendaries inside a box.
--      for legendaryIndex=1,6 do
--        local isDuplicate = true
--        while isDuplicate == true do
--          randomIndex = math.random(1, #(allExpansionLegendaries[curExpansion]))
--          isDuplicate = false
--          for previousLegendaryIndex=1,numBoxLegendaries do
--            if allExpansionLegendaries[curExpansion][randomIndex] == boxDiceCards[previousLegendaryIndex] then
--              isDuplicate = true
--            end
--          end
--        end
--        table.insert(boxDiceCards, allExpansionLegendaries[curExpansion][randomIndex])
--        numBoxLegendaries = numBoxLegendaries + 1
--      end
--
--      -- Rares can have duplicates inside a box.
--      for rareIndex=1,30 do
--        randomIndex = math.random(1, #(allExpansionRares[curExpansion]))
--        table.insert(boxDiceCards, allExpansionRares[curExpansion][randomIndex])
--      end
--
--      -- At this point, there are 36 dice cards that need randomized.
--      local diceCardsLeftToRandomize = 36
--      for i=1,36 do
--        randomIndex = math.random(1,diceCardsLeftToRandomize)
--        table.insert(expansionDiceCards, table.remove(boxDiceCards, randomIndex))
--        diceCardsLeftToRandomize = diceCardsLeftToRandomize - 1
--      end
--
--      -- Uncommons can have duplicates inside a box.
--      for uncommonIndex=1,36 do
--        randomIndex = math.random(1, #(allExpansionUncommons[curExpansion]))
--        table.insert(expansionUncommons, allExpansionUncommons[curExpansion][randomIndex])
--      end
--
--      -- Commons can have duplicates inside a box.
--      for commonIndex=1,108 do
--        randomIndex = math.random(1, #(allExpansionCommons[curExpansion]))
--        table.insert(expansionCommons, allExpansionCommons[curExpansion][randomIndex])
--      end
--    end
--
--    -- At this point, 2 boxes have been generated for the current expansion.  All 72 packs can now be saved.
--    local nextDiceCardIndex = 1
--    local nextUncommonIndex = 1
--    local nextCommonIndex = 1
--    nextExpansionIndex[curExpansion] = 1
--    rivalsExpansionPacks[curExpansion] = {}
--    for packIndex = 1,72 do
--      -- The packs are created in reverse order so that dice cards end up on top of decks.
--      table.insert(rivalsExpansionPacks[curExpansion], expansionCommons[nextCommonIndex])
--      nextCommonIndex = nextCommonIndex + 1
--      table.insert(rivalsExpansionPacks[curExpansion], expansionCommons[nextCommonIndex])
--      nextCommonIndex = nextCommonIndex + 1
--      table.insert(rivalsExpansionPacks[curExpansion], expansionCommons[nextCommonIndex])
--      nextCommonIndex = nextCommonIndex + 1
--
--      table.insert(rivalsExpansionPacks[curExpansion], expansionUncommons[nextUncommonIndex])
--      nextUncommonIndex = nextUncommonIndex + 1
--
--      table.insert(rivalsExpansionPacks[curExpansion], expansionDiceCards[nextDiceCardIndex])
--      nextDiceCardIndex = nextDiceCardIndex + 1
--    end
--  end
--end

--function allCardsDeckPulled(deck)
--  allCardsPulledDeck = deck
--  startLuaCoroutine(self, 'allCardsDeckPulledCoroutine')
--end

--function allCardsDeckPulledCoroutine()
--  local deck = allCardsPulledDeck
--  local rivalsMode = Global.getVar("rivalsMode")
--
--  local expansionPacksNeeded     = {}
--  local sortedPullCards          = {}
--  local numCardsPulled           = 0
--
--  for i,curExpansion in pairs(expansions) do
--    expansionPacksNeeded[curExpansion]    = 0
--    allExpansionLegendaries[curExpansion] = {}
--    allExpansionRares[curExpansion]       = {}
--    allExpansionUncommons[curExpansion]   = {}
--    allExpansionCommons[curExpansion]     = {}
--    sortedPullCards[curExpansion]         = {}
--  end
--
--  -- Set up local cube variables as well.
--  expansionPacksNeeded['Cube']          = 0
--  sortedPullCards['Cube']               = {}
--
--  if (rivalsExpansion != 'Mixed') then
--    -- Set all pack selections to the same expansion.
--    for i=1,numPacksPerPlayer do
--      packSelections[i] = rivalsExpansion
--    end
--  end
--
--  -- Determine how many cards from each expansion are needed.
--  for i=1,numPacksPerPlayer do
--    expansionPacksNeeded[packSelections[i]] = expansionPacksNeeded[packSelections[i]]+1
--  end
--
--  -- Generate tables for cards in each expansion.
--  local databank = Global.getTable("cardstable")
--  for index,curCard in ipairs(databank) do
--    local cardSet = curCard["set"]
--    local rarity = curCard["rarity"]
--
--    if "Legendary" == rarity then
--      table.insert(allExpansionLegendaries[cardSet], curCard["set"] .. ' ' .. curCard["number"])
--    elseif "Rare" == rarity then
--      table.insert(allExpansionRares[cardSet], curCard["set"] .. ' ' .. curCard["number"])
--    elseif "Uncommon" == rarity then
--      table.insert(allExpansionUncommons[cardSet], curCard["set"] .. ' ' .. curCard["number"])
--    elseif "Common" == rarity then
--      table.insert(allExpansionCommons[cardSet], curCard["set"] .. ' ' .. curCard["number"])
--    else
--      -- Nothing needs done.
--    end
--  end
--
--  local seatedPlayers = getSeatedPlayers()
--  local numSeatedPlayers = 0
--  for playerIndex,somePlayer in pairs(seatedPlayers) do
--    numSeatedPlayers = numSeatedPlayers + 1
--  end
--
--  -- Generate 2 boxes for each expansion.
--  generateBoxes()
--
--  printToAll("Preparing to pull cards...", {1,1,1})
--
--  coroutine.yield(0)
--
--  for expansionIndex,curExpansion in pairs(expansions) do
--    local numPacksToPull = (numSeatedPlayers*expansionPacksNeeded[curExpansion])
--
--    local cardIndex = 1
--    for packIndex=1,numPacksToPull do
--      -- Insert a pack at a time.
--      for i=1,5 do
--        table.insert(sortedPullCards[curExpansion], rivalsExpansionPacks[curExpansion][cardIndex])
--        cardIndex = cardIndex + 1
--      end
--    end
--
--    -- Sort the pull list.
--    table.sort(sortedPullCards[curExpansion])
--
--    -- Pull cards in the sorted pull list.
--    local numPullCards = #(sortedPullCards[curExpansion])
--    local cloneCard = nil
--    local lastNameOrDescription = nil
--    if numPullCards >= 1 then
--      for cardIndex=1,numPullCards do
--        if sortedPullCards[curExpansion][cardIndex] == lastNameOrDescription then
--          -- This is the same as the last card.  Clone it.
--          local cloneCardY = cloneCard.getPosition().y
--          local newCard = cloneCard.clone({position={6, (2 + (numCardsPulled * 0.05)) - cloneCardY, (-0.9)}})
--          newCard.locked = false
--          newCard.interactable = true
--          newCard.drag = 0.001
--          newCard.angular_drag = 0.001
--          newCard.dynamic_friction = 0.8
--          newCard.bounciness = 0
--
--          numCardsPulled = numCardsPulled + 1
--        else
--          -- This is a new card.  Delete the last card, pull the new one, and then clone it.
--          if cloneCard != nil then
--            cloneCard.destruct()
--          end
--
--          -- Find the GUID of the card.
--          local deckObjects = deck.getObjects()
--          local cardFound = false
--          for checkIndex,curCard in ipairs(deckObjects) do
--            if curCard.description == sortedPullCards[curExpansion][cardIndex] then
--              cardFound = true
--              local pullGuid = curCard.guid
--              if cubeCompatibilityMode == true then
--                lastNameOrDescription = curCard.nickname
--              else
--                lastNameOrDescription = curCard.description
--              end
--              cloneCard = deck.takeObject({position={200,1,200}, rotation={0,0,180}, guid=pullGuid, flip=false, smooth=false})
--              cloneCard.locked = true
--              cloneCard.interactable = false
--              cloneCard.drag = 0.001
--              cloneCard.angular_drag = 0.001
--              cloneCard.dynamic_friction = 0.8
--              cloneCard.bounciness = 0
--
--              local cloneCardY = cloneCard.getPosition().y
--              local newCard = cloneCard.clone({position={6, (2 + (numCardsPulled * 0.05)) - cloneCardY, (-0.9)}})
--              newCard.locked = false
--              newCard.interactable = true
--              newCard.drag = 0.001
--              newCard.angular_drag = 0.001
--              newCard.dynamic_friction = 0.8
--              newCard.bounciness = 0
--
--              numCardsPulled = numCardsPulled + 1
--              break
--            end
--          end
--
--          if cardFound == false then
--            -- This should never happen.
--            printToAll("Error, card \"" .. sortedPullCards[curExpansion][cardIndex] .. "\" not found.", {1,0,0})
--          end
--        end
--
--        -- Occasionally yield so the game does not freeze too much.
--        if ((numCardsPulled % 20) == 0) then
--          coroutine.yield(0)
--        end
--      end
--
--      if cloneCard != nil then
--        cloneCard.destruct()
--        cloneCard = nil
--      end
--    end
--  end
--
--  -- Add dummy cards so that once the deck is empty of useful cards, it will still be a "deck", and can be deleted.
--  -- Only do this for non-cube decks, since cube decks might not have enough spare cards.
--  if rivalsExpansion != 'Cube' then
--    deck.takeObject({position={6, 3 + (numCardsPulled * 0.1), (-0.9)}, rotation={0,0,180}, flip=false, smooth=false})
--    deck.takeObject({position={6, 3.1 + (numCardsPulled * 0.1), (-0.9)}, rotation={0,0,180}, flip=false, smooth=false})
--  end
--
--  -- Clone the Rivals deck for all players.
--  local scriptZoneObjects = getObjectFromGUID(rivalsDeckZoneGuid).getObjects()
--  local rivalsDeck = nil
--  for i,curDeck in ipairs(scriptZoneObjects) do
--    if curDeck.tag == "Deck" then
--      rivalsDeck = curDeck
--      break
--    end
--  end
--
--  if rivalsDeck != nil then
--    local seatData = Global.getTable("seatData")
--
--    for i,somePlayer in pairs(seatedPlayers) do
--      local clonePosition = nil
--
--      if ((rivalsMode == "Normal Draft") or (rivalsMode == "Cube Draft")) then
--        -- For normal draft or cube draft, clone on the Rivals deck holder.
--        clonePosition = getObjectFromGUID(seatData[somePlayer].rivalsDeckHolderGuid).getPosition()
--      else
--        -- For Winchester or sealed, clone on top of the deck area.
--        clonePosition = getObjectFromGUID(seatData[somePlayer].scriptZoneGuid).getPosition()
--      end
--      clonePosition.y = 1.5
--
--      local newRivalsDeck = rivalsDeck.clone({position=clonePosition})
--
--      -- Update the Rival deck rotation to be correct for each seat.
--      local rivalsDeckRotation = getObjectFromGUID(seatData[somePlayer].scriptZoneGuid).getRotation()
--
--      if ((rivalsMode == "Normal Draft") or (rivalsMode == "Cube Draft")) then
--        -- For normal draft or cube draft, rotate the Rivals deck to be face up.
--        rivalsDeckRotation.y = rivalsDeckRotation.y+180
--      else
--        -- For sealed and Winchester, flip the Rivals deck over.
--        rivalsDeckRotation.x = rivalsDeckRotation.x+180
--      end
--
--      newRivalsDeck.setRotation(rivalsDeckRotation)
--    end
--
--    -- After a delay, destruct the Rivals deck.
--    Wait.time(function() destructRivalsDeck(rivalsDeck) end, 1.5)
--  else
--    -- This should never happen.
--    printToAll("Error, Rivals deck not found.", {1,0,0})
--  end
--
--  -- Wait before dealing.  Note that this is a long time because cards for 8 players take a while.
--  Wait.time(function() draftReadyForDeal(deck) end, 3.5)
--
--  return 1
--end

--function destructRivalsDeck(rivalsDeck)
--  rivalsDeck.destruct()
--end

--function updatePackChoices(clickedPackIndex, clickedExpansionOffset)
--  packSelections[clickedPackIndex] = expansions[clickedExpansionOffset+1]
--
--  local clickedPackOffset = (clickedPackIndex-1)
--
--  for expansionOffset=0,(numExpansions-1) do
--    local editButtonParameters = {}
--
--    -- Change button colors to reflect the new selection.  Unlike Lua arrays, button indices start at 0.
--
--    editButtonParameters.index = ((clickedPackOffset * numExpansions) + expansionOffset)
--    if clickedExpansionOffset == expansionOffset then
--      editButtonParameters.color = {1,1,1}
--      editButtonParameters.font_color = {0,0,0}
--    else
--      editButtonParameters.color = {0,0,0}
--      editButtonParameters.font_color = {1,1,1}
--    end
--    self.editButton(editButtonParameters)
--  end
--end

-- Unfortunately, there seems to be no way to identify which button was clicked without using a million functions here or doing dynamic function generation.

--function packAW1()
--  updatePackChoices(1, 0)
--end
--
--function packAW2()
--  updatePackChoices(2, 0)
--end
--
--function packAW3()
--  updatePackChoices(3, 0)
--end
--
--function packAW4()
--  updatePackChoices(4, 0)
--end
--
--function packAW5()
--  updatePackChoices(5, 0)
--end
--
--function packAW6()
--  updatePackChoices(6, 0)
--end
--
--function packAW7()
--  updatePackChoices(7, 0)
--end
--
--function packAW8()
--  updatePackChoices(8, 0)
--end
--
--function packSoR1()
--  updatePackChoices(1, 1)
--end
--
--function packSoR2()
--  updatePackChoices(2, 1)
--end
--
--function packSoR3()
--  updatePackChoices(3, 1)
--end
--
--function packSoR4()
--  updatePackChoices(4, 1)
--end
--
--function packSoR5()
--  updatePackChoices(5, 1)
--end
--
--function packSoR6()
--  updatePackChoices(6, 1)
--end
--
--function packSoR7()
--  updatePackChoices(7, 1)
--end
--
--function packSoR8()
--  updatePackChoices(8, 1)
--end
--
--function packEaW1()
--  updatePackChoices(1, 2)
--end
--
--function packEaW2()
--  updatePackChoices(2, 2)
--end
--
--function packEaW3()
--  updatePackChoices(3, 2)
--end
--
--function packEaW4()
--  updatePackChoices(4, 2)
--end
--
--function packEaW5()
--  updatePackChoices(5, 2)
--end
--
--function packEaW6()
--  updatePackChoices(6, 2)
--end
--
--function packEaW7()
--  updatePackChoices(7, 2)
--end
--
--function packEaW8()
--  updatePackChoices(8, 2)
--end
--
--function packLEG1()
--  updatePackChoices(1, 3)
--end
--
--function packLEG2()
--  updatePackChoices(2, 3)
--end
--
--function packLEG3()
--  updatePackChoices(3, 3)
--end
--
--function packLEG4()
--  updatePackChoices(4, 3)
--end
--
--function packLEG5()
--  updatePackChoices(5, 3)
--end
--
--function packLEG6()
--  updatePackChoices(6, 3)
--end
--
--function packLEG7()
--  updatePackChoices(7, 3)
--end
--
--function packLEG8()
--  updatePackChoices(8, 3)
--end
--
--function packWotF1()
--  updatePackChoices(1, 4)
--end
--
--function packWotF2()
--  updatePackChoices(2, 4)
--end
--
--function packWotF3()
--  updatePackChoices(3, 4)
--end
--
--function packWotF4()
--  updatePackChoices(4, 4)
--end
--
--function packWotF5()
--  updatePackChoices(5, 4)
--end
--
--function packWotF6()
--  updatePackChoices(6, 4)
--end
--
--function packWotF7()
--  updatePackChoices(7, 4)
--end
--
--function packWotF8()
--  updatePackChoices(8, 4)
--end

--function heroButton()
--  if herobutton==true then
--    self.editButton({index=0,label='Hero'})
--    affiliationselect='nil'
--    if villainbutton!=true and neutralbutton != true then
--      affiliationselect='Hero'
--      affiliationselect2='Villain'
--      affiliationselect3='Neutral'
--    end
--    herobutton=false
--    return
--  end
--
--  if herobutton!=true then
--    self.editButton({index=0,label='!Hero!'})
--    herobutton=true
--    affiliationselect='Hero'
--    if villainbutton!=true and neutralbutton != true then
--      affiliationselect2='nil'
--      affiliationselect3='nil'
--    end
--    return
--  end
--end

--function villainButton()
--  if villainbutton==true then
--    self.editButton({index=1,label='villain'})
--    affiliationselect2='nil'
--    if herobutton!=true and neutralbutton != true then
--      affiliationselect='Hero'
--      affiliationselect2='Villain'
--      affiliationselect3='Neutral'
--    end
--    villainbutton=false
--    return
--  end
--
--  if villainbutton!=true then
--    self.editButton({index=1,label='!villain!'})
--    villainbutton=true
--    affiliationselect2='Villain'
--    if herobutton!=true and neutralbutton != true then
--      affiliationselect='nil'
--      affiliationselect3='nil'
--    end
--    return
--  end
--end

--function neutralButton()
--  if neutralbutton==true then
--    self.editButton({index=2,label='Neutral'})
--    affiliationselect3='nil'
--    if villainbutton!=true and herobutton != true then
--      affiliationselect='Hero'
--      affiliationselect2='villain'
--      affiliationselect3='Neutral'
--    end
--    neutralbutton=false
--    return
--  end
--
--  if neutralbutton!=true then
--    self.editButton({index=2,label='!Neutral!'})
--    neutralbutton=true
--    affiliationselect3='Neutral'
--    if villainbutton!=true and herobutton != true then
--      affiliationselect2='nil'
--      affiliationselect='nil'
--    end
--    return
--  end
--end

--function charactersButton()
--  if charactersbutton==true then
--    self.editButton({index=3,label='Characters'})
--    typeselect='nil'
--    if upgradesbutton!=true and supportsbutton != true and eventsbutton != true then
--      typeselect='Character'
--      typeselect2='Upgrade'
--      typeselect3='Support'
--      typeselect4='Event'
--    end
--    charactersbutton=false
--    return
--  end
--
--  if charactersbutton!=true then
--    self.editButton({index=3,label='!Character!'})
--    charactersbutton=true
--    typeselect='Character'
--    if upgradesbutton!=true and supportsbutton != true and eventsbutton != true then
--      typeselect2='nil'
--      typeselect3='nil'
--      typeselect4='nil'
--    end
--    return
--  end
--end

--function upgradesButton()
--  if upgradesbutton==true then
--    self.editButton({index=4,label='Upgrades'})
--    typeselect2='nil'
--    if charactersbutton!=true and supportsbutton != true and eventsbutton != true then
--      typeselect='Character'
--      typeselect2='Upgrade'
--      typeselect3='Support'
--      typeselect4='Event'
--    end
--    upgradesbutton=false
--    return
--  end
--
--  if upgradesbutton!=true then
--    self.editButton({index=4,label='!Upgrades!'})
--    upgradesbutton=true
--    typeselect2='Upgrade'
--    if charactersbutton!=true and supportsbutton != true and eventsbutton != true then
--      typeselect='nil'
--      typeselect3='nil'
--      typeselect4='nil'
--    end
--    return
--  end
--end

--function supportsButton()
--  if supportsbutton==true then
--    self.editButton({index=5,label='Supports'})
--    typeselect3='nil'
--    if charactersbutton!=true and upgradesbutton != true and eventsbutton != true then
--      typeselect='Character'
--      typeselect2='Upgrade'
--      typeselect3='Support'
--      typeselect4='Event'
--    end
--    supportsbutton=false
--    return
--  end
--
--  if supportsbutton!=true then
--    self.editButton({index=5,label='!Supports!'})
--    supportsbutton=true
--    typeselect3='Support'
--    if charactersbutton!=true and upgradesbutton != true and eventsbutton != true then
--      typeselect='nil'
--      typeselect2='nil'
--      typeselect4='nil'
--    end
--    return
--  end
--end

--function eventsButton()
--  if eventsbutton==true then
--    self.editButton({index=6,label='Events'})
--    typeselect4='nil'
--    if charactersbutton!=true and upgradesbutton != true and supportsbutton != true then
--      typeselect='Character'
--      typeselect2='Upgrade'
--      typeselect3='Support'
--      typeselect4='Event'
--    end
--    eventsbutton=false
--    return
--  end
--
--  if eventsbutton!=true then
--    self.editButton({index=6,label='!Events!'})
--    eventsbutton=true
--    typeselect4='Event'
--    if charactersbutton!=true and upgradesbutton != true and supportsbutton != true then
--      typeselect='nil'
--      typeselect2='nil'
--      typeselect3='nil'
--    end
--    return
--  end
--end

--function redButton()
--  if redbutton==true then
--    self.editButton({index=7,label='Red'})
--    colorselect='nil'
--    if bluebutton!=true and yellowbutton != true and greybutton != true then
--      colorselect='Red'
--      colorselect2='Blue'
--      colorselect3='Yellow'
--      colorselect4='Gray'
--    end
--    redbutton=false
--    return
--  end
--
--  if redbutton!=true then
--    self.editButton({index=7,label='!Red!'})
--    redbutton=true
--    colorselect='Red'
--    if bluebutton!=true and yellowbutton != true and greybutton != true then
--      colorselect2='nil'
--      colorselect3='nil'
--      colorselect4='nil'
--    end
--    return
--  end
--end

--function blueButton()
--  if bluebutton==true then
--    self.editButton({index=8,label='Blue'})
--    colorselect2='nil'
--    if redbutton!=true and yellowbutton != true and greybutton != true then
--      colorselect='Red'
--      colorselect2='Blue'
--      colorselect3='Yellow'
--      colorselect4='Gray'
--    end
--    bluebutton=false
--    return
--  end
--
--  if bluebutton!=true then
--    self.editButton({index=8,label='!Blue!'})
--    bluebutton=true
--    colorselect2='Blue'
--    if redbutton!=true and yellowbutton != true and greybutton != true then
--      colorselect='nil'
--      colorselect3='nil'
--      colorselect4='nil'
--    end
--    return
--  end
--end

--function yellowButton()
--  if yellowbutton==true then
--    self.editButton({index=9,label='Yellow'})
--    colorselect3='nil'
--    if redbutton!=true and bluebutton != true and greybutton != true then
--      colorselect='Red'
--      colorselect2='Blue'
--      colorselect3='Yellow'
--      colorselect4='Gray'
--    end
--    yellowbutton=false
--    return
--  end
--
--  if yellowbutton!=true then
--    self.editButton({index=9,label='!Yellow!'})
--    yellowbutton=true
--    colorselect3='Yellow'
--    if redbutton!=true and bluebutton != true and greybutton != true then
--      colorselect='nil'
--      colorselect2='nil'
--      colorselect4='nil'
--    end
--    return
--  end
--end

--function greyButton()
--  if greybutton==true then
--    self.editButton({index=10,label='Gray'})
--    colorselect4='nil'
--    if redbutton!=true and bluebutton != true and yellowbutton != true then
--      colorselect='Red'
--      colorselect2='Blue'
--      colorselect3='Yellow'
--      colorselect4='Gray'
--    end
--    greybutton=false
--    return
--  end
--
--  if greybutton!=true then
--    self.editButton({index=10,label='!Grey!'})
--    greybutton=true
--    colorselect4='Gray'
--    if redbutton!=true and bluebutton != true and yellowbutton != true then
--      colorselect='nil'
--      colorselect2='nil'
--      colorselect3='nil'
--    end
--    return
--  end
--end

--function battlefieldsButton()
--  if battlefieldbutton !=true then
--    self.editButton({index=11,label='!Battlefields!'})
--    battlefieldbutton=true
--    return
--  end
--
--  if battlefieldbutton ==true then
--    self.editButton({index=11,label='Battlefields'})
--    battlefieldbutton=false
--    return
--  end
--
--end

--function setupDeckbuilding()
--  --broadcastToAll('Check Steam workshop page for instructions!', {255,255,255})
--  local object = setupObject.takeObject({position={28,1,6.5},guid='1cc719'})
--  object.interactable = false
--  object = setupObject.takeObject({position={28,1,12},guid='cf8e15'})
--  object.interactable = false
--
--  self.clearButtons()
--  self.createButton({
--    label='Hero', click_function="heroButton", function_owner=self,
--      position={-1,0.1,-1}, width=500, height=150,font_size=90
--  })
--
--  self.createButton({
--    label='villain', click_function="villainButton", function_owner=self,
--      position={-0,0.1,-1}, width=500, height=150,font_size=90
--  })
--
--  self.createButton({
--    label='Neutral', click_function="neutralButton", function_owner=self,
--      position={1,0.1,-1}, width=500, height=150,font_size=90
--  })
--
--  self.createButton({
--    label='Characters', click_function="charactersButton", function_owner=self,
--      position={-0.6,0.1,-0.4}, width=600, height=150,font_size=90
--  })
--
--  self.createButton({
--    label='Upgrades', click_function="upgradesButton", function_owner=self,
--      position={0.6,0.1,-0.4}, width=600, height=150,font_size=90
--  })
--
--  self.createButton({
--    label='Supports', click_function="supportsButton", function_owner=self,
--      position={-0.6,0.1,-0.1}, width=600, height=150,font_size=90
--  })
--
--  self.createButton({
--    label='Events', click_function="eventsButton", function_owner=self,
--      position={0.6,0.1,-0.1}, width=600, height=150,font_size=90
--  })
--
--  self.createButton({
--    label='Red',click_function="redButton",function_owner=self,
--    position={-1.2,0.1,0.5},width = 400, height = 150, font_size = 90
--  })
--
--  self.createButton({
--    label='Blue',click_function="blueButton",function_owner=self,
--    position={-0.4,0.1,0.5},width = 400, height = 150, font_size = 90
--  })
--
--  self.createButton({
--    label='Yellow',click_function="yellowButton",function_owner=self,
--    position={0.4,0.1,0.5},width = 400, height = 150, font_size = 90
--  })
--
--  self.createButton({
--    label='Gray',click_function="greyButton",function_owner=self,
--    position={1.2,0.1,0.5},width = 400, height = 150, font_size = 90
--  })
--
--  self.createButton({
--    label='Battlefields', click_function="battlefieldsButton", function_owner=self,
--    position={0,0.1,1.1}, width=800, height=150,font_size=90
--  })
--
--  self.createButton({
--    label='Spawn',click_function="spawndb",function_owner=self,
--    position={-1.3,0.1,1.7},width = 400, height = 150, font_size = 100
--  })
--
--  self.createButton({
--    label='Back',click_function="dbBack",function_owner=self,
--    position={1.3,0.1,1.7},width = 400, height = 150, font_size = 100
--  })
--end

function spawnSetupButton(buttonObject, playerColor)
  local errorDetected = false

  if ((blue == nil) or (blue == 0)) then
    broadcastToAll('No number of characters chosen for blue!', {1,1,1})
    errorDetected = true
  end

  if ((red == nil) or (red == 0)) then
    broadcastToAll('No number of characters chosen for red!', {1,1,1})
    errorDetected = true
  end

  local seatedPlayers = getSeatedPlayers()
  local numSeatedPlayers = 0
  for i,somePlayer in pairs(seatedPlayers) do
    numSeatedPlayers = numSeatedPlayers + 1
  end

  if ((numSeatedPlayers == 1) or (numSeatedPlayers == 2)) then
    if (errorDetected == false) then
      -- Zoom camera back out to the normal perspective for that player.
      zoomCameraBackOut(playerColor)

      -- Delay slightly so camera movement does not feel too sudden.
      Wait.time(function() spawnSetupButtonAfterDelay(playerColor) end, 0.2)
    end
  else
    printToAll("Error, two-player games must have 1 or 2 seated players.", {1,0,0})
  end
end

function spawnSetupButtonAfterDelay(playerColor)
  startLuaCoroutine(self, 'spawnSetupCoroutine')
end


characterPlaymatScript = [[
function onload()
  tokenplayerone = Global.getTable('tokenplayerone')
  tokenplayertwo = Global.getTable('tokenplayertwo')
  spawndamage = {}
  damagetoken = {}
  spawnshield = {}
  shieldtoken = {}

  for i = 1, 5 do
      local buttonNum = tostring(i)
      local funcName = "spawnDamage" .. tostring(i)
      local params = { click_function = funcName
                      , function_owner = self
                      , label = ' '
                      , position = {-1.65,0,-1.70+0.30*i}
                      , width = 100
                      , height = 100
                      , font_size = 50 }
      local func = function()
        local position = self.getPosition()
        local moving = setSpawnPositions({4.50, -4.65, 0.8, 0})
        position = {(position[1]+moving[1]+moving[4]*i),(position[2]+0.2),(position[3]+moving[2]+moving[3]*i)}
        if spawndamage[i] == nil then
          if damagetoken[i] ~= nil then damagetoken[i].destruct() end
          damagetoken[i] = spawnToken(position, '1')
          spawndamage[i] = 'one'
          damagetoken[i].interactable = false
          return
        elseif spawndamage[i] == 'one' then
          if damagetoken[i] ~= nil then damagetoken[i].destruct() end
          damagetoken[i] = spawnToken(position, '2')
          spawndamage[i] = 'three'
          damagetoken[i].interactable = false
          return
        elseif spawndamage[i] == 'three' then
          if damagetoken[i] ~= nil then damagetoken[i].destruct() end
          spawndamage[i] = nil
          return
        end
      end
      self.setVar(funcName, func)
      self.createButton(params)
  end

  for i = 1, 3 do
      local buttonNum = tostring(i)
      local funcName = "spawnShield" .. tostring(i)
      local params = { click_function = funcName
                      , function_owner = self
                      , label = ' '
                      , position = {-1.30+0.35*i,0,-1.72}
                      , width = 100
                      , height = 100
                      , font_size = 50 }
      local func = function()
        if spawnshield[i] ~= true then
          if shieldtoken[i] ~= nil then shieldtoken[i].destruct() end
          local position = self.getPosition()
          local moving = setSpawnPositions({3.60, -4.75, -1, 0})
          position = {(position[1]+moving[1]+moving[3]*i),(position[2]+0.1),(position[3]+moving[2]-moving[4]*i)}
          shieldtoken[i] = spawnToken(position, '3')
          spawnshield[i] = true
          shieldtoken[i].interactable = false
          return
        elseif spawnshield[i] == true then
          if shieldtoken[i] ~= nil then shieldtoken[i].destruct() end
          spawnshield[i] = false
          return
        end
      end
      self.setVar(funcName, func)
      self.createButton(params)
  end

  if self.getName() == 'Blue' then
    owner = 'Blue'
  else
    owner = 'Red'
  end
end

function spawnToken(position, number)
  local obj_parameters = {}
  obj_parameters.type = 'Custom_Token'
  obj_parameters.position = position
  obj_parameters.rotation = {3.87674022, self.getRotation()[2], 0.239081308}
  local token = spawnObject(obj_parameters)
  local custom = {}
  custom.thickness = 0.1
  custom.merge_distance = 5.0
  custom.stackable = false
  if number == '1' then
    custom.image = tokenplayerone.damageone
  elseif number == '2' then
    custom.image = tokenplayerone.damagethree
  elseif number == '3' then
    custom.image = tokenplayerone.shield
  else
    return nil
  end
  token.setCustomObject(custom)
  token.scale {0.227068469, 1, 0.227068469}
  return token
end

function onCollisionEnter(collision_info)
--  local position = self.getPosition()
--  local object = collision_info.collision_object
--  local obj_parameters = {}
--  local custom = {}
--  obj_parameters.type = 'Custom_Dice'
--  obj_parameters.scale = {1.7,1.7,1.7}
--  obj_parameters.position = {object.getPosition()[1],object.getPosition()[2]+1,object.getPosition()[3]}
--  obj_parameters.rotation = {0,object.getRotation()[2]+180,0}
--  local datatable = Global.getTable("cardstable")
--
--  if object.getVar("spawned") ~= true and object.tag == 'Card' then
--    local cardFound = false
--    local cardDescription = object.getDescription()
--    local cardDescriptionLength = 0
--    local dataTableIndex = 1
--    local fixedCardName = ''
--    local isElite = false
--
--    if cardDescription != nil then
--      cardDescriptionLength = string.len(cardDescription)
--      if string.sub(cardDescription, 1, 5) == 'elite' then
--        isElite = true
--      end
--    end
--
--    -- If there is text past "elite", or the card is not elite and there is text at all, the card uses the new format.
--    if (((isElite == true) and (cardDescriptionLength > 5)) or
--        ((isElite == false) and (cardDescriptionLength > 0))) then
--      -- This is a new card export.  Extract the set and number.
--      local cardSet = ''
--      local cardNumber = ''
--      local setCharIndex = 1
--      local numberCharIndex = 1
--      if (isElite == true) then
--        setCharIndex = 7
--      else
--        setCharIndex = 1
--      end
--
--      -- Do a plain search.
--      numberCharIndex = (string.find(cardDescription, ' ', setCharIndex, true) + 1)
--      cardSet = string.sub(cardDescription, setCharIndex, (numberCharIndex - 2))
--      -- Leaving out the third argument takes a substring to the end of the string.
--      cardNumber = string.sub(cardDescription, numberCharIndex)
--
--      -- Find the card by its set and number.
--      for i in ipairs(datatable) do
--        if ((datatable[i]["set"] == cardSet) and
--            (datatable[i]["number"] == cardNumber) and
--            (datatable[i]["diceimage"] != nil) and
--            ((datatable[i]["type"] == 'Upgrade') or (datatable[i]["type"] == 'Character') or (datatable[i]["type"] == 'Battlefield'))) then
--          cardFound = true
--          dataTableIndex = i
--          fixedCardName = datatable[dataTableIndex]["cardname"]
--          object.setName(fixedCardName)
--          break
--        end
--      end
--
--      local diceSpawnDebug = Global.getVar("diceSpawnDebug")
--
--      if (cardFound == false) then
--        if diceSpawnDebug == true then
--          printToAll("Error, card " .. cardSet .. " " .. cardNumber .. " not found (make sure it is not a support).", {1,0,0})
--        end
--      end
--    else
--      -- This is an old card export.  Use the old system.
--      fixedCardName = Global.call("fixCardName", { object.getName() })
--      object.setName(fixedCardName)
--      for i in ipairs(datatable) do
--        if ((datatable[i]["cardname"] == fixedCardName) and
--            (datatable[i]["diceimage"] != nil) and
--            ((datatable[i]["type"] == 'Upgrade') or (datatable[i]["type"] == 'Character') or (datatable[i]["type"] == 'Battlefield'))) then
--          cardFound = true
--          dataTableIndex = i
--          break
--        end
--      end
--
--      if (cardFound == false) then
--        if diceSpawnDebug == true then
--          printToAll("Error, card " .. fixedCardName .. " not found (make sure it is not a support).", {1,0,0})
--        end
--      end
--    end
--
--    if (cardFound == true) then
--      -- For character cards, spawn the dice on the table for ease of rollout.
--      zOffset = 0
--      if (datatable[dataTableIndex]["type"] == 'Character') then
--        if owner == 'Blue' then
--          zOffset = (-6)
--        else
--          zOffset = 5
--        end
--      end
--
--      collision_info.collision_object.setVar("spawned", true)
--      obj_parameters.position[3] = (obj_parameters.position[3] + zOffset)
--      local dice = spawnObject(obj_parameters)
--      custom.image = datatable[dataTableIndex]["diceimage"]
--      dice.setCustomObject(custom)
--      if (fixedCardName == 'Seventh Sister, Agile Inquisitor') then
--        obj_parameters.position = {object.getPosition()[1]+1, object.getPosition()[2]+1, (object.getPosition()[3] + zOffset)}
--        local extradice = spawnObject(obj_parameters)
--        custom.image = "http://cloud-3.steamusercontent.com/ugc/869614883116891249/E95F6BDCAD82D95AEEFF7798BA2EB89013F1C530/"
--        extradice.setCustomObject(custom)
--        custom.image = datatable[dataTableIndex]["diceimage"]
--      end
--
--      if (isElite == true) then
--        obj_parameters.position = {object.getPosition()[1], object.getPosition()[2]+1, (object.getPosition()[3] + 1 + zOffset)}
--        local dice = spawnObject(obj_parameters)
--        dice.setCustomObject(custom)
--      end
--    end
--  end
end

function setSpawnPositions(position)
  if self.getRotation()[2] < 5 and self.getRotation()[2] > -5 then
    return {position[1], position[2], position[3], position[4]}
  elseif self.getRotation()[2] < 95 and self.getRotation()[2] > 85 then
    return {position[2], position[1]*-1, position[4], position[3]}
  elseif self.getRotation()[2] < 185 and self.getRotation()[2] > 175 then
    return {position[1]*-1, position[2]*-1, position[3]*-1, position[4]}
  elseif self.getRotation()[2] < 275 and self.getRotation()[2] > 265 then
    return {position[2]*-1, position[1], position[4], position[3]*-1}
  end
end
]]


supportPlaymatScript = [[
function onLoad()
  tokenplayerone = Global.getTable('tokenplayerone')
  tokenplayertwo = Global.getTable('tokenplayertwo')
end

function onCollisionEnter(collision_info)
--  local position = self.getPosition()
--  local object = collision_info.collision_object
--  local obj_parameters = {}
--  local custom = {}
--  obj_parameters.type = 'Custom_Dice'
--  obj_parameters.scale = {1.7,1.7,1.7}
--  obj_parameters.position = {object.getPosition()[1],object.getPosition()[2]+1,object.getPosition()[3]}
--  obj_parameters.rotation = {0,object.getRotation()[2]+180,0}
--  local datatable = Global.getTable("cardstable")
--
--  if object.getVar("spawned") ~= true and object.tag == 'Card' then
--    local cardFound = false
--    local cardDescription = object.getDescription()
--    local cardDescriptionLength = 0
--    local dataTableIndex = 1
--    local fixedCardName = ''
--    local isElite = false
--
--    if cardDescription != nil then
--      cardDescriptionLength = string.len(cardDescription)
--      if string.sub(cardDescription, 1, 5) == 'elite' then
--        isElite = true
--      end
--    end
--
--    -- If there is text past "elite", or the card is not elite and there is text at all, the card uses the new format.
--    if (((isElite == true) and (cardDescriptionLength > 5)) or
--        ((isElite == false) and (cardDescriptionLength > 0))) then
--      -- This is a new card export.  Extract the set and number.
--      local cardSet = ''
--      local cardNumber = ''
--      local setCharIndex = 1
--      local numberCharIndex = 1
--      if (isElite == true) then
--        setCharIndex = 7
--      else
--        setCharIndex = 1
--      end
--
--      -- Do a plain search.
--      numberCharIndex = (string.find(cardDescription, ' ', setCharIndex, true) + 1)
--      cardSet = string.sub(cardDescription, setCharIndex, (numberCharIndex - 2))
--      -- Leaving out the third argument takes a substring to the end of the string.
--      cardNumber = string.sub(cardDescription, numberCharIndex)
--
--      -- Find the card by its set and number.
--      for i in ipairs(datatable) do
--        if ((datatable[i]["set"] == cardSet) and
--            (datatable[i]["number"] == cardNumber) and
--            ((datatable[i]["type"] == 'Support') or (datatable[i]["type"] == 'Battlefield'))) then
--          cardFound = true
--          dataTableIndex = i
--          fixedCardName = datatable[dataTableIndex]["cardname"]
--          object.setName(fixedCardName)
--          break
--        end
--      end
--
--      local diceSpawnDebug = Global.getVar("diceSpawnDebug")
--
--      if (cardFound == false) then
--        if diceSpawnDebug == true then
--          printToAll("Error, card " .. cardSet .. " " .. cardNumber .. " not found (make sure it is actually a support).", {1,0,0})
--        end
--      end
--    else
--      -- This is an old card export.  Use the old system.
--      fixedCardName = Global.call("fixCardName", { object.getName() })
--      object.setName(fixedCardName)
--      for i in ipairs(datatable) do
--        if ((datatable[i]["cardname"] == fixedCardName) and
--            ((datatable[i]["type"] == 'Support') or (datatable[i]["type"] == 'Battlefield'))) then
--          cardFound = true
--          dataTableIndex = i
--          break
--        end
--      end
--
--      if (cardFound == false) then
--        if diceSpawnDebug == true then
--          printToAll("Error, card " .. fixedCardName .. " not found (make sure it is actually a support).", {1,0,0})
--        end
--      end
--    end
--
--    if (cardFound == true) then
--      collision_info.collision_object.setVar("spawned", true)
--
--      if (datatable[dataTableIndex]["diceimage"] != nil) then
--        local dice = spawnObject(obj_parameters)
--        custom.image = datatable[dataTableIndex]["diceimage"]
--        dice.setCustomObject(custom)
--      end
--
--      if (fixedCardName == "Backup Muscle") then
--        collision_info.collision_object.setVar("spawned", true)
--        obj_parameters.type = 'Custom_Token'
--        obj_parameters.rotation = {3.87674022, 0, 0.239081308}
--        obj_parameters.scale = {0.227068469, 1, 0.227068469}
--        for i=1,3 do
--          obj_parameters.position = {collision_info.collision_object.getPosition()[1]-1.5+(i*0.7),collision_info.collision_object.getPosition()[2]+0.2,collision_info.collision_object.getPosition()[3]-1.5+(i*0.7)}
--          local token = spawnObject(obj_parameters)
--          local custom = {}
--          custom.image = tokenplayerone.damageone
--          custom.thickness = 0.1
--          custom.merge_distance = 5.0
--          custom.stackable = false
--          token.setCustomObject(custom)
--        end
--      elseif (fixedCardName == "Modified HWK-290") then
--        collision_info.collision_object.setVar("spawned", true)
--        obj_parameters.type = 'Custom_Token'
--        obj_parameters.rotation = {3.87674022, 0, 0.239081308}
--        obj_parameters.scale = {0.227068469, 1, 0.227068469}
--        for i=1,2 do
--          obj_parameters.position = {collision_info.collision_object.getPosition()[1]-1.5+(i*0.7),collision_info.collision_object.getPosition()[2]+0.2,collision_info.collision_object.getPosition()[3]-1.5+(i*0.7)}
--          local token = spawnObject(obj_parameters)
--          local custom = {}
--          custom.image = tokenplayerone.damageone
--          custom.thickness = 0.1
--          custom.merge_distance = 5.0
--          custom.stackable = false
--          token.setCustomObject(custom)
--        end
--      elseif (fixedCardName == "Air Superiority") then
--        collision_info.collision_object.setVar("spawned", true)
--        obj_parameters.type = 'Custom_Token'
--        obj_parameters.rotation = {3.87674022, 0, 0.239081308}
--        obj_parameters.scale = {0.227068469, 1, 0.227068469}
--        for i=1,3 do
--          obj_parameters.position = {collision_info.collision_object.getPosition()[1]-1.5+(i*0.7),collision_info.collision_object.getPosition()[2]+0.2,collision_info.collision_object.getPosition()[3]-1.5+(i*0.7)}
--          local token = spawnObject(obj_parameters)
--          local custom = {}
--          custom.image = tokenplayerone.shield
--          custom.thickness = 0.1
--          custom.merge_distance = 5.0
--          custom.stackable = false
--          token.setCustomObject(custom)
--        end
--      end
--
--      if (isElite == true) then
--        printToAll("Error, supports cannot be elite.  Ignoring tag.", {1,0,0})
--      end
--    end
--  end
end

function setSpawnPositions(position)
  if self.getRotation()[2] < 5 and self.getRotation()[2] > -5 then
    return {position[1], position[2], position[3], position[4]}
  elseif self.getRotation()[2] < 95 and self.getRotation()[2] > 85 then
    return {position[2], position[1]*-1, position[4], position[3]}
  elseif self.getRotation()[2] < 185 and self.getRotation()[2] > 175 then
    return {position[1]*-1, position[2]*-1, position[3]*-1, position[4]}
  elseif self.getRotation()[2] < 275 and self.getRotation()[2] > 265 then
    return {position[2]*-1, position[1], position[4], position[3]*-1}
  end
end
]]


datapadScript = [[
function onLoad()
  tokenplayerone = Global.getTable('tokenplayerone')
  tokenplayertwo = Global.getTable('tokenplayertwo')

  --self.createButton({
  --  label=" ", click_function="spawnResource", function_owner=self, tooltip="Get a resource",
  --  position={-0.1,-0.2,0.26}, width=1200, height=150, font_size=200, color={1,1,1,0.6}
  --})

  --self.createButton({
  --  label=" ", click_function="randomDiscard", function_owner=self, tooltip="Discard a random card",
  --  position={-0.1,-0.2,0.56}, width=1200, height=150, font_size=200, color={1,1,1,0.6}
  --})

  self.createButton({
    label=" ", click_function="shuffleHand", function_owner=self, tooltip="Shuffle your hand",
    position={-0.1,-0.2,0.87}, width=1200, height=150, font_size=200, color={1,1,1,0.6}
  })

  self.createButton({
    label=" ", click_function="passButton", function_owner=self, tooltip="Pass",
    position={-0.1,-0.2,1.07}, width=1200, height=150, font_size=200, color={1,1,1,0.6}
  })

  spawnd = 0

  if self.getName() == 'Blue Datapad' then
    owner = 'Blue'
  else
    owner = 'Red'
  end
end

--function passButton()
--  if owner == 'Blue' then
--    broadcastToAll('Pass', {0.1,0.5,1.0})
--  else
--    broadcastToAll('Pass', {0.8,0.1,0.1})
--  end
--end

--function resourceSpawned(newResource)
--  newResource.setName("1 resource")
--  newResource.tooltip = false
--end

--function spawnResource()
--  local position = self.getPosition()
--  local obj_parameters = {}
--  obj_parameters.type = 'Custom_Token'
--  if owner == 'Blue' then
--    obj_parameters.position = {(position[1]+2.60-spawnd),(position[2]+0.2),(position[3]-6.55)}
--    obj_parameters.rotation = {3.87674022, 0, 0.239081308}
--  else
--    obj_parameters.position = {(position[1]-2.60+spawnd),(position[2]+0.2),(position[3]+6.55)}
--    obj_parameters.rotation = {3.87674022, 180, 0.239081308}
--  end
--  obj_parameters.callback_function = resourceSpawned
--  local token = spawnObject(obj_parameters)
--  local custom = {}
--  custom.image = tokenplayerone.resource
--  custom.thickness = 0.1
--  custom.merge_distance = 5.0
--  custom.stackable = false
--  token.setCustomObject(custom)
--  token.scale {0.227068469, 1, 0.227068469}
--  spawnd = spawnd + 0.8
--  if spawnd > 4.8 then
--    spawnd = 0
--  end
--end

function randomDiscard()
  local handObjects = Player[owner].getHandObjects()
  local numHandObjects = #handObjects
  local position=self.getPosition()

  if numHandObjects > 0 then
    if owner == 'Blue' then
      handObjects[math.random(numHandObjects)].setPosition({position[1]-math.random(10)+5,1.2,position[3]-10})
    else
      handObjects[math.random(numHandObjects)].setPosition({position[1]+math.random(10)-5,1.2,position[3]+10})
    end
  end
end

function shuffleHand()
  local handObjects = Player[owner].getHandObjects()
  local numHandObjects = #handObjects
  local cardPositions = {}

  if numHandObjects > 0 then
    for i, v in pairs(handObjects) do
        cardPositions[i] = v.getPosition()
    end
    local handObjectsShuffled = shuffleTable(handObjects)
    local cardPositionsShuffled = shuffleTable(cardPositions)
    for i, v in pairs(handObjectsShuffled) do
        v.setPosition(cardPositionsShuffled[i])
    end
  end
end

function shuffleTable(t)
    for i = #t, 2, -1 do
        local n = math.random(i)
        t[i], t[n] = t[n], t[i]
    end
    return t
end
]]


function spawnSetupCoroutine()
  -- Start classic setup.
  Global.setVar("modernInterfaceActive", false)

  -- Sleep briefly and start.
  Wait.time(spawnSetupAfterDelay, 0.1)

  return 1
end

function spawnSetupAfterDelay()
  startLuaCoroutine(self, 'spawnSetupAfterDelayCoroutine')
end

function spawnSetupAfterDelayCoroutine()
  local seatData = Global.getTable("seatData")

  -- Destruct all draft mats.
  local matObject
  for i,someSeat in pairs(seatData) do
    matObject = getObjectFromGUID(someSeat.matGuid)
    if matObject != nil then
      matObject.destruct()
    end
  end

  -- Scale all hand zones down so they don't grab cards.
  for i,someSeat in pairs(seatData) do
    local handTransform = Player[i].getHandTransform()
    handTransform.scale.x = 0.01
    handTransform.scale.y = 0.01
    handTransform.scale.z = 0.01
    Player[i].setHandTransform(handTransform)
  end

  -- Adjust the red and blue hand zones to be usable.
  local handTransform = Player["Red"].getHandTransform()
  handTransform.position.x = -1.70
  handTransform.position.y = 4.60
  handTransform.position.z = (-20.00)
  handTransform.rotation.x = 0.00
  handTransform.rotation.y = 0.00
  handTransform.rotation.z = 0.00
  handTransform.scale.x = 20.00
  handTransform.scale.y = 5.65
  handTransform.scale.z = 3.00
  Player["Red"].setHandTransform(handTransform)
  handTransform = Player["Blue"].getHandTransform()
  handTransform.position.x = 1.70
  handTransform.position.y = 4.60
  handTransform.position.z = 20.00
  handTransform.rotation.x = 0.00
  handTransform.rotation.y = 180.00
  handTransform.rotation.z = 0.00
  handTransform.scale.x = 20.00
  handTransform.scale.y = 5.65
  handTransform.scale.z = 3.00
  Player["Blue"].setHandTransform(handTransform)

  local seatedPlayers = getSeatedPlayers()
  local numSeatedPlayers = 0
  for i,somePlayer in pairs(seatedPlayers) do
    numSeatedPlayers = numSeatedPlayers + 1
  end

  if ((numSeatedPlayers == 1) or (numSeatedPlayers == 2)) then
    local firstPlayerToAssign = nil
    local secondPlayerToAssign = nil
    local blueUsed = false
    local redUsed = false
    local colorChangeNeeded = false
    for i,somePlayer in pairs(seatedPlayers) do
      if somePlayer == "Blue" then
        blueUsed = true
      elseif somePlayer == "Red" then
        redUsed = true
      else
        if firstPlayerToAssign == nil then
          firstPlayerToAssign = somePlayer
          colorChangeNeeded = true
        else
          secondPlayerToAssign = somePlayer
          colorChangeNeeded = true
        end
      end
    end

    -- If either or both players are not blue/red, change their color(s).

    if firstPlayerToAssign != nil then
      if blueUsed == false then
        Player[firstPlayerToAssign].changeColor("Blue")
        blueUsed = true
      else
        -- If blue is used, then red must not be used, otherwise firstPlayerToAssign would be nil.
        Player[firstPlayerToAssign].changeColor("Red")
        redUsed = true
      end
    end

    if secondPlayerToAssign != nil then
      -- If neither player was blue or red, the first player got assigned to blue, so this one should be red.
      Player[secondPlayerToAssign].changeColor("Red")
      redUsed = true
    end

    if colorChangeNeeded == true then
      printToAll("Two-player games only use the Blue and Red seats.", {1,1,1})
    end
  else
    printToAll("Error, two-player games must have 1 or 2 seated players.", {1,0,0})

    return 1
  end

  -- At this point, a normal game is considered to have started.
  Global.call("handleNormalGameStarted")

  local object = {}
  local params = {}
  params.type = 'Custom_Token'
  if blue == 1 then
    startposition = {0,1.1,10.38}
  end

  if blue == 2 then
    startposition = {6.7,1.1,10.38}
  end

  if blue == 3  then
    startposition = {9.7,1.1,10.38}
  end

  if blue == 4 then
    startposition = {16.7,1.1,10.38}
  end

  params.rotation = {0,0,0}
  params.scale = {2.74,0,2.74}
  object.image = 'http://cloud-3.steamusercontent.com/ugc/194046562276974641/B5CB1D9F2683C4F1FA6A053A67475E057CC989F7/'
  object.thickness = 0.2
  object.merge_distance = 5.0
  for i=1,blue do
    params.position = {startposition[1]-(10.3*(i-1)),startposition[2],startposition[3]}
    local spawner = spawnObject(params)
    spawner.setCustomObject(object)
    spawner.setName('Blue')
    spawner.setLuaScript(characterPlaymatScript)
    spawner.lock()
  end

  params.position = {startposition[1]+8,1.1,10.38}
  params.scale = {1.88,0,1.88}
  local spawner = spawnObject(params)
  object.image = 'http://cloud-3.steamusercontent.com/ugc/194046562276975653/436A9517517DADEA3F5C9427E7E5EFB4F8844ACB/'
  spawner.setCustomObject(object)
  spawner.setName('Support Playmat')
  spawner.setLuaScript(supportPlaymatScript)
  spawner.lock()

  params.position = {startposition[1]-(10.2*blue),1.1,10.21}
  params.scale = {2.73, 1, 2.73}
  token = spawnObject(params)
  object.image = 'http://cloud-3.steamusercontent.com/ugc/858355343478176189/9F708B25DB0EE25A89A93BE7D3F3C3FB9F6DF6EA/'
  object.thickness = 0.30
  token.setCustomObject(object)
  token.setName('Blue Datapad')
  token.setLuaScript(datapadScript)
  token.lock()

  if red == 1 then
    startposition = {0,1.1,-10.38}
  end

  if red == 2 then
    startposition = {-6.7,1.1,-10.38}
  end

  if red == 3 then
    startposition = {-9.7,1.1,-10.38}
  end

  if red == 4 then
    startposition = {-16.7,1.1,-10.38}
  end

  params.rotation = {0,180,0}
  params.scale = {2.74,0,2.74}
  object.image = 'http://cloud-3.steamusercontent.com/ugc/194046562276974641/B5CB1D9F2683C4F1FA6A053A67475E057CC989F7/'
  object.thickness = 0.2
  object.merge_distance = 5.0
  for i=1,red do
    params.position = {startposition[1]+(10.3*(i-1)),startposition[2],startposition[3]}
    local spawner = spawnObject(params)
    spawner.setCustomObject(object)
    spawner.setName('Red')
    spawner.setLuaScript(characterPlaymatScript)
    spawner.lock()
  end

  params.position = {startposition[1]-8,1.1,-10.38}
  params.scale = {1.88,0,1.88}
  local spawner = spawnObject(params)
  object.image = 'http://cloud-3.steamusercontent.com/ugc/194046562276975653/436A9517517DADEA3F5C9427E7E5EFB4F8844ACB/'
  spawner.setCustomObject(object)
  spawner.setName('Support Playmat')
  spawner.setLuaScript(supportPlaymatScript)
  spawner.lock()

  params.position = {startposition[1]+(10.2*red),1.1,-10.21}
  params.scale = {2.73, 1, 2.73}
  token = spawnObject(params)
  object.image = 'http://cloud-3.steamusercontent.com/ugc/858355343478176189/9F708B25DB0EE25A89A93BE7D3F3C3FB9F6DF6EA/'
  object.thickness = 0.30
  token.setCustomObject(object)
  token.setName('Red Datapad')
  token.setLuaScript(datapadScript)
  token.lock()

  coroutine.yield(0)
  coroutine.yield(0)

  setupObject.destruct()
  self.destruct()

  if starterGame == true then
    startLuaCoroutine(self, 'spawnStarter')
  end

  return 1
end

function movePlayerBoards()
  blueResourceZone.setPosition({-23.00, 2.51, 0.32})
  blueBattlefieldZone.setPosition({-18.39, 2.51, 0.27})
  blueMatZone.setPosition({4.82, 0.90, 10.20})
  blueBoardsPrefab.setPosition({-20.85, 0.97, 10.05})

  redResourceZone.setPosition({23.00, 2.51, -0.32})
  redResourceZone.setRotation({0, 180, 0})
  redBattlefieldZone.setPosition({18.39, 2.51, -0.27})
  redBattlefieldZone.setRotation({0, 180, 0})
  redMatZone.setPosition({-4.82, 0.90, -10.20})
  redMatZone.setRotation({0, 180, 0})
  redBoardsPrefab.setPosition({20.85, 0.97, -10.05})
  redBoardsPrefab.setRotation({0, 0, 0})

  Global.setVar("blueBoardsPrefab", blueBoardsPrefab)
  Global.setVar("blueResourceZone", blueResourceZone)
  Global.setVar("blueBattlefieldZone", blueBattlefieldZone)
  Global.setVar("blueMatZone", blueMatZone)

  Global.setVar("redBoardsPrefab", redBoardsPrefab)
  Global.setVar("redResourceZone", redResourceZone)
  Global.setVar("redBattlefieldZone", redBattlefieldZone)
  Global.setVar("redMatZone", redMatZone)
end

function red1()
  self.editButton({index=1,label='Red: 2 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=2,label='Red: 3 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=3,label='Red: 4 Characters',color={1,1,1},font_color={0,0,0}})
  red = 1
  self.editButton({index=0,label='!Red: 1 Character!',color={0.8,0.1,0.1},font_color={1,1,1}})
end

function red2()
  self.editButton({index=0,label='Red: 1 Character',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=2,label='Red: 3 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=3,label='Red: 4 Characters',color={1,1,1},font_color={0,0,0}})
  red = 2
  self.editButton({index=1,label='!Red: 2 Characters!',color={0.8,0.1,0.1},font_color={1,1,1}})
end

function red3()
  self.editButton({index=0,label='Red: 1 Character',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=1,label='Red: 2 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=3,label='Red: 4 Characters',color={1,1,1},font_color={0,0,0}})
  red = 3
  self.editButton({index=2,label='!Red: 3 Characters!',color={0.8,0.1,0.1},font_color={1,1,1}})
end

function red4()
  self.editButton({index=0,label='Red: 1 Character',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=1,label='Red: 2 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=2,label='Red: 3 Characters',color={1,1,1},font_color={0,0,0}})
  red = 4
  self.editButton({index=3,label='!Red: 4 Characters!',color={0.8,0.1,0.1},font_color={1,1,1}})
end

function blue1()
  self.editButton({index=5,label='Blue: 2 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=6,label='Blue: 3 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=7,label='Blue: 4 Characters',color={1,1,1},font_color={0,0,0}})
  blue = 1
  self.editButton({index=4,label='!Blue: 1 Character!',color={0.1,0.5,1.0},font_color={1,1,1}})
end

function blue2()
  self.editButton({index=4,label='Blue: 1 Character',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=6,label='Blue: 3 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=7,label='Blue: 4 Characters',color={1,1,1},font_color={0,0,0}})
  blue = 2
  self.editButton({index=5,label='!Blue: 2 Characters!',color={0.1,0.5,1.0},font_color={1,1,1}})
end

function blue3()
  self.editButton({index=4,label='Blue: 1 Character',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=5,label='Blue: 2 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=7,label='Blue: 4 Characters',color={1,1,1},font_color={0,0,0}})
  blue = 3
  self.editButton({index=6,label='!Blue: 3 Characters!',color={0.1,0.5,1.0},font_color={1,1,1}})
end

function blue4()
  self.editButton({index=4,label='Blue: 1 Character',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=5,label='Blue: 2 Characters',color={1,1,1},font_color={0,0,0}})
  self.editButton({index=6,label='Blue: 3 Characters',color={1,1,1},font_color={0,0,0}})
  blue = 4
  self.editButton({index=7,label='!Blue: 4 Characters!',color={0.1,0.5,1.0},font_color={1,1,1}})
end

function dbBack()
  if spawnditems ~= nil then
    for i in pairs(spawnditems) do
      if getObjectFromGUID(spawnditems[i])!= nil then
        getObjectFromGUID(spawnditems[i]).destruct()
      end
    end
  end
  local object = getObjectFromGUID('1cc719')
  object.setPosition({28,2,2})
  object.interactable=true
  local object = getObjectFromGUID('cf8e15')
  object.setPosition({28,4,2})
  object.interactable=true

  self.setPosition{0,1,0}
  spawnditems={}
  mainMenu()
  affiliationselect='Hero'
  affiliationselect2='Villain'
  affiliationselect3='Neutral'
  typeselect='Character'
  typeselect2='Upgrade'
  typeselect3='Support'
  typeselect4='Event'
  colorselect='Red'
  colorselect2='Blue'
  colorselect3='Yellow'
  colorselect4='Gray'
  battlefieldbutton=false
  redbutton = false
  bluebutton = false
  yellowbutton = false
  greybutton = false
  charactersbutton = false
  upgradesbutton = false
  eventsbutton = false
  supportsbutton = false
  herobutton = false
  villainbutton = false
  neutralbutton = false

end

function redtokenclassic()
  token = {
    damageone = "http://cloud-3.steamusercontent.com/ugc/194046562280483535/A29691412CEC7FDE752A603736EBB99405CC347B/",
    damagethree = "http://cloud-3.steamusercontent.com/ugc/194046562280484252/758430B535676DA603F0041356827EE9BD7B830A/",
    shield = "http://cloud-3.steamusercontent.com/ugc/194046562280485442/DA82F2C7D32BF37A2CB403635876FF96D7D1B0E8/",
    resource = "http://cloud-3.steamusercontent.com/ugc/194046562280484903/A696882BD4631043881D60F55CC823EE1FC7BE1D/"
  }
  Global.setTable('tokenplayerone', token)
  self.editButton({index=12,label='!Red: Classic!'})
  self.editButton({index=9,label='Red: BrokenEgg LS'})
  self.editButton({index=8,label='Red: BrokenEgg DS'})
end

function bluetokenclassic()
  token = {
    damageone = "http://cloud-3.steamusercontent.com/ugc/194046562280483535/A29691412CEC7FDE752A603736EBB99405CC347B/",
    damagethree = "http://cloud-3.steamusercontent.com/ugc/194046562280484252/758430B535676DA603F0041356827EE9BD7B830A/",
    shield = "http://cloud-3.steamusercontent.com/ugc/194046562280485442/DA82F2C7D32BF37A2CB403635876FF96D7D1B0E8/",
    resource = "http://cloud-3.steamusercontent.com/ugc/194046562280484903/A696882BD4631043881D60F55CC823EE1FC7BE1D/"
  }
  Global.setTable('tokenplayertwo', token)
  self.editButton({index=13,label='!Blue: Classic!'})
  self.editButton({index=10,label='Blue: BrokenEgg LS'})
  self.editButton({index=11,label='Blue: BrokenEgg DS'})
end

function redtokenls()
  token = {
    damageone = "http://cloud-3.steamusercontent.com/ugc/138878581189337871/63224277C5E0CCD81E5623C78329C2B053801F5B/",
    damagethree = "http://cloud-3.steamusercontent.com/ugc/138878581189338583/F235212117B6FD1BB4FC4B043F0EC9DAF569F524/",
    shield = "http://cloud-3.steamusercontent.com/ugc/138878581189344376/524AA619CACA1109F1B0A469C9C9859A364F86BD/",
    resource = "http://cloud-3.steamusercontent.com/ugc/138878581189343694/82BE715910B90A4A5569BAD0DB945B283CAEB1E1/"
  }
  Global.setTable('tokenplayerone', token)
  self.editButton({index=12,label='Red: Classic'})
  self.editButton({index=9,label='!Red: BrokenEgg LS!'})
  self.editButton({index=8,label='Red: BrokenEgg DS'})
end

function redtokends()
  token = {
    damageone = "http://cloud-3.steamusercontent.com/ugc/138878581189341027/478EF1F25A98207586F29710DEDA956B5CC5C798/",
    damagethree = "http://cloud-3.steamusercontent.com/ugc/138878581189342765/9149CFBF36AF9E1B58B348527545B95653B90BF5/",
    shield = "http://cloud-3.steamusercontent.com/ugc/138878581189340289/234BB8378F5AF4E842976CBA8AD0C14F7246E13B/",
    resource = "http://cloud-3.steamusercontent.com/ugc/138878581189339560/A134B915FD6DD175F8056A5C808B11AD5F73230A/"
  }
  Global.setTable('tokenplayerone', token)
  self.editButton({index=12,label='Red: Classic'})
  self.editButton({index=9,label='Red: BrokenEgg LS'})
  self.editButton({index=8,label='!Red: BrokenEgg DS!'})
end

function bluetokenls()
  token = {
    damageone = "http://cloud-3.steamusercontent.com/ugc/138878581189337871/63224277C5E0CCD81E5623C78329C2B053801F5B/",
    damagethree = "http://cloud-3.steamusercontent.com/ugc/138878581189338583/F235212117B6FD1BB4FC4B043F0EC9DAF569F524/",
    shield = "http://cloud-3.steamusercontent.com/ugc/138878581189344376/524AA619CACA1109F1B0A469C9C9859A364F86BD/",
    resource = "http://cloud-3.steamusercontent.com/ugc/138878581189343694/82BE715910B90A4A5569BAD0DB945B283CAEB1E1/"
  }
  Global.setTable('tokenplayertwo', token)
  self.editButton({index=13,label='Blue: Classic'})
  self.editButton({index=10,label='!Blue: BrokenEgg LS!'})
  self.editButton({index=11,label='Blue: BrokenEgg DS'})
end

function bluetokends()
  token = {
    damageone = "http://cloud-3.steamusercontent.com/ugc/138878581189341027/478EF1F25A98207586F29710DEDA956B5CC5C798/",
    damagethree = "http://cloud-3.steamusercontent.com/ugc/138878581189342765/9149CFBF36AF9E1B58B348527545B95653B90BF5/",
    shield = "http://cloud-3.steamusercontent.com/ugc/138878581189340289/234BB8378F5AF4E842976CBA8AD0C14F7246E13B/",
    resource = "http://cloud-3.steamusercontent.com/ugc/138878581189339560/A134B915FD6DD175F8056A5C808B11AD5F73230A/"
  }
  Global.setTable('tokenplayertwo', token)
  self.editButton({index=13,label='Blue: Classic'})
  self.editButton({index=10,label='Blue: BrokenEgg LS'})
  self.editButton({index=11,label='!Blue: BrokenEgg DS!'})
end

function redtokentcsaga()
  token = {
    damageone = "http://cloud-3.steamusercontent.com/ugc/102851052181836065/6DD94520F5D424BBF0F9E0FABCF8FD22305BCA36/",
    damagethree = "http://cloud-3.steamusercontent.com/ugc/102851052181834275/A6699914EDB3C0F45CEBBC6C0C3E90DA28E96E26/",
    shield = "http://cloud-3.steamusercontent.com/ugc/102851052181842011/05D809854B7D3788095964674BED5C1BFC0407E7/",
    resource = "http://cloud-3.steamusercontent.com/ugc/102851052181837876/FBB02E7AB22AD194A4E1023E3D2F3E3615F72B26/"
  }
  Global.setTable('tokenplayerone', token)
  self.editButton({index=12,label='Red: Classic'})
  self.editButton({index=9,label='Red: BrokenEgg LS'})
  self.editButton({index=8,label='Red: BrokenEgg DS'})
  self.editButton({index=14, label = '!Red: TC Saga!'})
end

function bluetokentcsaga()
  token = {
    damageone = "http://cloud-3.steamusercontent.com/ugc/102851052181836065/6DD94520F5D424BBF0F9E0FABCF8FD22305BCA36/",
    damagethree = "http://cloud-3.steamusercontent.com/ugc/102851052181834275/A6699914EDB3C0F45CEBBC6C0C3E90DA28E96E26/",
    shield = "http://cloud-3.steamusercontent.com/ugc/102851052181842011/05D809854B7D3788095964674BED5C1BFC0407E7/",
    resource = "http://cloud-3.steamusercontent.com/ugc/102851052181837876/FBB02E7AB22AD194A4E1023E3D2F3E3615F72B26/"
  }
  Global.setTable('tokenplayertwo', token)
  self.editButton({index=13,label='Blue: Classic'})
  self.editButton({index=10,label='Blue: BrokenEgg LS'})
  self.editButton({index=11,label='Blue: BrokenEgg DS'})
  self.editButton({index=15, label ='!Blue: TC Saga!'})
end